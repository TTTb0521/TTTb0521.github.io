<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图</title>
    <url>/2025/04/17/Graph/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><blockquote>
<p>顶点集、边集、顶点数目、边数目<br><img src="/2025/04/17/Graph/Graph.png" alt="alt text"></p>
</blockquote>
<h3 id="有向图和无向图的区别"><a href="#有向图和无向图的区别" class="headerlink" title="有向图和无向图的区别"></a>有向图和无向图的区别</h3><p>有向图的边集$\mathbf{E}$中的元素有序而无向图的边集$\mathbf{E’}$中的元素无序</p>
<blockquote>
<p><img src="/2025/04/17/Graph/G.png" alt="alt text"></p>
</blockquote>
<h3 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h3><p>不存在自环和多重边（两条边的起点和终点相同）<br><mark><em>这里讨论的都是简单图</em></mark></p>
<h3 id="无向完全图和有向完全图的区别"><a href="#无向完全图和有向完全图的区别" class="headerlink" title="无向完全图和有向完全图的区别"></a>无向完全图和有向完全图的区别</h3><p>完全图：图中的每个顶点和其余顶点都有边相连<br><strong>无向完全图的边数:$e = n (n - 1) / 2$<br>有向完全图的边数:$e = n (n - 1)$</strong></p>
<p><strong>拥有$n$个顶点的无向图一共有$2 ^ {n (n - 1) / 2}$种<br>拥有$n$个顶点的有向图一共有$2 ^ {n (n - 1)}$种</strong></p>
<blockquote>
<p><strong>为什么？</strong><br>有向图和无向图最多可能有的边数就是他们成为完全图的边数</p>
</blockquote>
<h3 id="子图和超图"><a href="#子图和超图" class="headerlink" title="子图和超图"></a>子图和超图</h3><p><img src="/2025/04/17/Graph/子图和超图.png" alt="alt text"><br><strong>每个图都是自身的子图，空图是任何图的子图</strong><br><strong>拥有$n$个顶点的图一定是这$n$个顶点组成的完全图的子图</strong></p>
<h3 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h3><p>顶点的度记作$TD(v)$，入度记作$ID(v)$，出度记作$OD(v)$<br><strong>有：$ TD(v) = ID(v) + OD(v) $</strong><br><strong>度为奇数的顶点成为奇点，度为偶数的顶点称为偶点</strong></p>
<blockquote>
<p><strong>重要性质：</strong><br>有向图中所有顶点入度之和等于所有顶点出度之和<mark><em>（每条边贡献一个入度和一个出度）</em></mark></p>
<p><strong>握手定理：</strong><br>图中所有顶点度之和等于边数目的2倍<mark><em>（每条边贡献两个度）</em></mark></p>
<p><strong>推论一：</strong><br>有向图中所有顶点入度或出度之和等于边数目<br><strong>推论二：</strong><br>任意图中一定有偶数个（含0）奇点</p>
<p><mark><strong>对于树来说：</strong></mark></p>
<ul>
<li>边数等于度数之和</li>
<li>边数等于节点数减一</li>
</ul>
</blockquote>
<h3 id="路径和回路"><a href="#路径和回路" class="headerlink" title="路径和回路"></a>路径和回路</h3><p>没有重复节点，则成为简单路径/回路</p>
<h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p>无向图中$G$，如果任意两个顶点都是连通的，则$G$是连通图；有向图$G$中，如果任意两个顶点都存在路径，则$G$是强连通图<br><strong><em>极大连通子图（连通分量）</em></strong>：该图是$G$的连通子图，将$G$中任何不在该子图中的顶点加入，子图将不再连通<br><img src="/2025/04/17/Graph/极大连通子图.png" alt="alt text"></p>
<h3 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h3><p><img src="/2025/04/17/Graph/补图.png" alt="alt text"></p>
<h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>形变过后得到的图<br><img src="/2025/04/17/Graph/同构.png" alt="alt text"></p>
<h2 id="线性表、树、图的比较"><a href="#线性表、树、图的比较" class="headerlink" title="线性表、树、图的比较"></a>线性表、树、图的比较</h2><p><img src="/2025/04/17/Graph/比较.png" alt="alt text"></p>
<h2 id="欧拉路径和回路"><a href="#欧拉路径和回路" class="headerlink" title="欧拉路径和回路"></a>欧拉路径和回路</h2><p>欧拉路径:图中经过每条边且仅经过每条边一次的路径<br>欧拉回路:终点和起点重合的欧拉路径</p>
<p><strong>定理：</strong><br><img src="/2025/04/17/Graph/欧拉路径和回路.png" alt="alt text"></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>通常采用两个数组来表示一个图<br>其一用来存储顶点信息；其二用来存储顶点的关联情况，称为邻接矩阵<br>顶点信息：<br><img src="/2025/04/17/Graph/顶点信息.png" alt="alt text"><br>邻接矩阵：<br><img src="/2025/04/17/Graph/无向图的邻接矩阵.png" alt="alt text"><br><img src="/2025/04/17/Graph/有向图的邻接矩阵.png" alt="alt text"><br><img src="/2025/04/17/Graph/有向赋权图的邻接矩阵.png" alt="alt text"></p>
<p><strong><em>重要特点：无向图的邻接矩阵对称，有向图则不一定</em></strong></p>
<h3 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h3><p><img src="/2025/04/17/Graph/邻接矩阵实现.png" alt="alt text"></p>
<blockquote>
<p><strong>为什么添加/删除顶点的时间复杂度是$O(n^2)$?</strong><br>邻接矩阵通过 ​n×n 的二维数组 存储顶点间的边关系。当添加一个新顶点时：<br>​需要将原矩阵<strong>从 n×n 扩容到 (n+1)×(n+1)</strong>，即创建一个新的二维数组。<strong>复制原有 n×n 数据到新数组</strong>，并初始化新增行/列（通常用 0 填充表示无边）。这一过程中，​<mark>复制原有数据需要遍历所有 n² 个元素，因此时间复杂度为 O(n²)。</mark></p>
</blockquote>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><img src="/2025/04/17/Graph/邻接表.png" alt="alt text"></p>
<p><strong>有向图</strong>每个链表的长度等于顶点的<strong>出度</strong>，总共需要<mark>$(n + e)$</mark>个链表结点<br><strong>无向图</strong>每个链表的长度等于顶点的<strong>度</strong>，总共需要<mark>$(n + 2e)$</mark>个链表结点</p>
<p>邻接表的实现：<br><img src="/2025/04/17/Graph/邻接表的实现.png" alt="alt text"><br><strong>注意插入边和删除边的时间复杂度不同</strong></p>
<h3 id="邻接矩阵和邻接表的比较"><a href="#邻接矩阵和邻接表的比较" class="headerlink" title="邻接矩阵和邻接表的比较"></a>邻接矩阵和邻接表的比较</h3><p><img src="/2025/04/17/Graph/邻接矩阵和邻接表的比较.png" alt="alt text"></p>
<blockquote>
<p><strong>稠密图</strong>适于采用<strong>邻接矩阵</strong>表示<br>大规模的<strong>稀疏图</strong>$(e &lt;&lt; n^2)$，适于采用<strong>邻接表</strong>表示</p>
</blockquote>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><p><strong>代码实现：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ElemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Graph&lt;ElemType&gt;::<span class="built_in">DFS</span>(<span class="type">int</span> v)&#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="built_in">FirstAdjVex</span>(v); t != <span class="number">-1</span>; t = <span class="built_in">NextAdjVex</span>(v,t))&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[t] == <span class="number">0</span>) <span class="built_in">DFS</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>稠密图适于在邻接矩阵上进行深度遍历;稀疏图适于在邻接表上进行深度遍历。</em></strong></p>
<h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><p>类似<strong>层序遍历</strong></p>
<p><img src="/2025/04/17/Graph/广搜1.png" alt="alt text"><br><img src="/2025/04/17/Graph/广搜2.png" alt="alt text"></p>
<h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><p><strong>时间复杂度：</strong><br>用邻接矩阵来表示图时,遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为$O(n)$，总共是$O(n^2)$。用邻接表来表示图时，虽然有$2e$个表结点，<strong>但只需扫描$e$个结点即可完成遍历</strong>，加上访问$n$个头结点的时间，时间复杂度为$O(n+e)$。</p>
<h2 id="图遍历的应用"><a href="#图遍历的应用" class="headerlink" title="图遍历的应用"></a>图遍历的应用</h2><ol>
<li>寻找图中从顶点$v$到顶点$w$的简单路径<br>使用DFS，路径删除规则：维护一条路径P依次记录DFS中访问的顶点，<strong>如果某顶点全部邻接点均被访问仍没有到达$w$</strong>，则从路径中删除此顶点;最终到达$w$时，路径中记录的即为从$v$到$w$的一条简单路径</li>
</ol>
<p><strong>下图中的1和3满足路径删除规则：</strong><br><img src="/2025/04/17/Graph/DFS1.png" alt="alt text"><br><img src="/2025/04/17/Graph/DFS2.png" alt="alt text"></p>
<ol>
<li>无权图中从顶点$v$到顶点$w$的最短路径<br>使用BFS</li>
</ol>
<h3 id="遍历与图的连通性"><a href="#遍历与图的连通性" class="headerlink" title="遍历与图的连通性"></a>遍历与图的连通性</h3><p>关节点与桥：</p>
<p><img src="/2025/04/17/Graph/关节点与桥.png" alt="alt text"></p>
<p><strong><em>注意：无向连通图的顶点度都为偶数，则该图没有桥</em></strong></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><strong>无向连通图的生成树:包含图中全部n个顶点，但仅有 $n-1$ 条边的连通子图</strong><br>满足以下条件：</p>
<ul>
<li>生成树上删除一边则不再连通</li>
<li>生成树上添加一条边则一定会产生回路</li>
<li>生成树可以理解为’极小’连通图，且可以不唯<br><img src="/2025/04/17/Graph/最小生成树.png" alt="alt text"></li>
</ul>
<p><strong>最小生成树：</strong></p>
<ul>
<li><strong>赋权图生成树的权</strong>:组成生成树的 $n-1$ 条边的权之和</li>
<li><strong>生成树的权不大于其它任何生成树，称为最小生成树</strong></li>
<li>如果<strong>图中有相等权值的边</strong>，则MST可能不唯一</li>
</ul>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p><strong>本质上是一种贪心算法，每次选择权值最小的边</strong><br><img src="/2025/04/17/Graph/Prim算法1.png" alt="alt text"><br><img src="/2025/04/17/Graph/Prim算法2.png" alt="alt text"></p>
<p>对于<strong>邻接矩阵和邻接表来说，时间复杂度都为 $O(n^2)$</strong><br>这是因为：每次迭代需要遍历所有 $n$ 个顶点来寻找最小权重边，找到新顶点后，需要遍历邻接矩阵中该顶点的所有 $n$ 个邻接点来更新权重，总时间 $O(n^2)$</p>
<blockquote>
<p><strong>为什么Prim算法得到的一定是MST？</strong></p>
<p><strong>Prim算法</strong>一定能得到最小生成树（MST）的根本原因在于其设计严格遵循了MST的<strong>两个核心数学性质</strong>，并通过<strong>贪心策略</strong>保证每一步选择的边都安全地属于MST。以下是详细解释：</p>
<p><strong>​1. 切割定理（Cut Property）的保证</strong><br><mark>Prim算法的核心逻辑是：​每次选择连接”已选顶点集合（MST部分）”与”未选顶点集合”的最小权重边。</mark><br><strong>​切割定理：若将图划分为两个顶点集合（例如已选集合$U$和未选集合$V-U$），则连接这两个集合的最小权重边一定属于MST。</strong><br>​算法行为：每次选出的边，本质上就是当前切割（已选顶点与未选顶点之间的分割）的最小权重边。</p>
<p><strong>​2. 无环性的维护</strong><br>​顶点增量扩展：算法每次仅将一个新顶点加入已选集合$U$<mark>且该顶点从未属于$U$</mark>。<br>​边连接方式：新加入的边始终连接$U$和$V-U$，<mark>不会在$U$内部形成回路，也不会在$V-U$内部形成回路</mark>。<br>​树形结构保持：已选边集<mark>始终构成一棵树（无环且连通）</mark>，直到覆盖所有顶点。</p>
<p><strong>​3. 贪心策略的全局最优性</strong><br>​局部最优蕴含全局最优：<strong>通过归纳法可证明，每次选择的局部最优边最终能组合成全局最优解：</strong><br>​初始状态：空树是MST的平凡情况（权值和为0）。<br>​归纳假设：假设前k步已选择的边构成某棵MST的边子集。<br>​递推步骤：根据切割定理，第k+1步选择的边必然属于某棵MST，最终所有顶点加入后，整体构成MST。</p>
</blockquote>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p><strong>也是一种贪心算法，重要特征是放弃环路.<mark>环路的判断采用等价类思想(并查集)</mark>，将已连通的顶点均用其中一个顶点代表</strong></p>
<p>算法步骤：<br><img src="/2025/04/17/Graph/Kruskal算法.png" alt="alt text"></p>
<p><strong>算法复杂度为：$O(eloge)$</strong></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><blockquote>
<p>一些特点：</p>
<ul>
<li><strong><em>最短路径存在的<mark>充要条件</mark>：图中不存在负环。</em></strong></li>
<li><strong><em>正权图中，如果存在最短路径，则一定不包含环</em></strong></li>
<li><strong><em>最短路径中任意一段也是局部最短路径（整体最优蕴含了局部最优）</em></strong></li>
</ul>
</blockquote>
<h3 id="Dijkstra算法-单源最短路径"><a href="#Dijkstra算法-单源最短路径" class="headerlink" title="Dijkstra算法(单源最短路径)"></a>Dijkstra算法(单源最短路径)</h3><p><mark><strong>算法的时间复杂度为：$O(n^2)$</strong></mark></p>
<p><img src="/2025/04/17/Graph/Dijkstra.png" alt="alt text"></p>
<p>图示：<br><img src="/2025/04/17/Graph/D算法1.png" alt="alt text"><br><img src="/2025/04/17/Graph/D算法2.png" alt="alt text"><br><img src="/2025/04/17/Graph/D算法3.png" alt="alt text"></p>
<h3 id="Floyd算法-全源最短路径"><a href="#Floyd算法-全源最短路径" class="headerlink" title="Floyd算法(全源最短路径)"></a>Floyd算法(全源最短路径)</h3><p><strong>若对每个顶点使用Dijkstra算法，则算法复杂度为$O(n^3)$</strong></p>
<p><strong>Floyd算法的复杂度也为$O(n^3)$，但是它允许负权边，不允许包含负回路</strong></p>
<p>算法思想：<br><img src="/2025/04/17/Graph/Floyd算法.png" alt="alt text"></p>
<p>比如：<br><img src="/2025/04/17/Graph/Floyd算法1.png" alt="alt text"><br><img src="/2025/04/17/Graph/Floyd算法2.png" alt="alt text"></p>
<p>或者采用逐步加入顶点的思想来理解：<br><img src="/2025/04/17/Graph/F算法3.png" alt="alt text"></p>
<p><img src="/2025/04/17/Graph/F算法4.png" alt="alt text"></p>
<p><img src="/2025/04/17/Graph/F算法5.png" alt="alt text"></p>
<p><img src="/2025/04/17/Graph/F算法6.png" alt="alt text"></p>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p><strong>重要思想：边松弛</strong><br><img src="/2025/04/17/Graph/边松弛.png" alt="alt text"></p>
<p>比如：<br><img src="/2025/04/17/Graph/B算法1.png" alt="alt text"><br><img src="/2025/04/17/Graph/B算法2.png" alt="alt text"><br><img src="/2025/04/17/Graph/B算法3.png" alt="alt text"></p>
<h3 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h3><p><img src="/2025/04/17/Graph/算法对比.png" alt="alt text"></p>
]]></content>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2025/03/17/LinearList/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><blockquote>
<p>线性表（linear list）：具有相同性质的数据元素<mark>顺序排列</mark>形成的优先序列</p>
</blockquote>
<p>由于顺序存储结构存在以下问题：</p>
<ul>
<li>存储空间分配不灵活</li>
<li>运算的空间复杂度高</li>
</ul>
<p><strong>因此，链式存储结构更佳</strong></p>
<h2 id="顺序表——线性表的顺序存储方式"><a href="#顺序表——线性表的顺序存储方式" class="headerlink" title="顺序表——线性表的顺序存储方式"></a>顺序表——线性表的顺序存储方式</h2><blockquote>
<p><strong>顺序表有以下特点</strong>：<br>数据元素依次顺序存储在一组<mark>连续的存储单元</mark>中，知道某个元素的位置就可以计算其他元素，获得任意元素的复杂度为$O(1)$<br>数据元素的<mark>物理存放顺序与其逻辑顺序一致</mark></p>
</blockquote>
<h3 id="顺序表的查找操作"><a href="#顺序表的查找操作" class="headerlink" title="顺序表的查找操作"></a>顺序表的查找操作</h3><p>顺序查找的ASL（<mark>Average Search Length</mark>）<br><img src="/2025/03/17/LinearList/顺序表查找的ASL.png" alt="alt text"><br>假设每个元素查找的概率相等：$P_i = 1/n$<br>则$ASL =（1 + 2 + 3 +…+n）/ n = (n + 1) / 2$<br><strong><em>时间复杂度为$O(n)$</em></strong></p>
<h3 id="顺序表的插入操作"><a href="#顺序表的插入操作" class="headerlink" title="顺序表的插入操作"></a>顺序表的插入操作</h3><p><strong>算法步骤</strong>：</p>
<ol>
<li>判断插入位置是否合法</li>
<li>判断顺序表的存储空间是否已满，已满则返回False</li>
<li>空出第 i 个位置，将第 n 至第 i 位的元素依次向后移动一个位置</li>
<li>将要插入的新元素放入第 i 个位置</li>
<li>表长加一</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ol>
<li>在第 i 个位置插入元素的先验概率$P_i = 1 / n + 1$</li>
<li>则期望为：<br><img src="/2025/03/17/LinearList/顺序表插入的期望.png" alt="alt text"></li>
</ol>
<p><strong><em>插入一个元素的平均时间复杂度为$O(n)$</em></strong></p>
<h3 id="顺序表的删除操作"><a href="#顺序表的删除操作" class="headerlink" title="顺序表的删除操作"></a>顺序表的删除操作</h3><p><strong>算法步骤</strong>：</p>
<ol>
<li>判断插入位置是否合法</li>
<li>将待删除的元素保留</li>
<li>空出第 i + 1 个位置至第 n 位的元素依次向前移动一个位置</li>
<li>表长减一</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ol>
<li>在第 i 个位置删除元素的先验概率$P_i = 1 / n$</li>
<li>共有 n - i - 1 个元素需要移动</li>
<li>则期望为：<br><img src="/2025/03/17/LinearList/顺序表删除的期望.png" alt="alt text"><br><strong><em>删除一个元素的平均时间复杂度为$O(n)$</em></strong></li>
</ol>
<h3 id="顺序表的优缺点"><a href="#顺序表的优缺点" class="headerlink" title="顺序表的优缺点"></a>顺序表的优缺点</h3><ul>
<li>可以<mark>直接访问</mark>表中的元素</li>
<li>插入/删除操作设计<mark>大量元素移动</mark>，复杂度高</li>
<li>静态存储，<mark>不可扩充</mark></li>
</ul>
<h2 id="单向链表——线性表的链式存储方式"><a href="#单向链表——线性表的链式存储方式" class="headerlink" title="单向链表——线性表的链式存储方式"></a>单向链表——线性表的链式存储方式</h2><blockquote>
<p><strong>单向链表表有以下特点</strong>：<br>存储单元<strong>可以不连续</strong><br>用<mark>额外的存储空间</mark>存放数据元素的逻辑位置<br>采用<mark>指针链接</mark>逻辑相邻的元素</p>
</blockquote>
<h3 id="在链表中插入新节点"><a href="#在链表中插入新节点" class="headerlink" title="在链表中插入新节点"></a>在链表中插入新节点</h3><p><img src="/2025/03/17/LinearList/单向链表的插入.png" alt="alt text"><br><strong>步骤</strong>：</p>
<ol>
<li><code>s -&gt; next = p -&gt; next</code></li>
<li><code>p -&gt; next = s</code></li>
</ol>
<p><strong><em>颠倒顺序会导致自循环</em></strong><br><br></p>
<h3 id="在链表中删除节点"><a href="#在链表中删除节点" class="headerlink" title="在链表中删除节点"></a>在链表中删除节点</h3><p><img src="/2025/03/17/LinearList/单向链表的删除.png" alt="alt text"><br><strong>步骤</strong>：</p>
<ol>
<li><code>q = p -&gt; next</code></li>
<li><code>p -&gt; next = q -&gt; next</code></li>
<li><code>delete q; q = null</code></li>
</ol>
<h3 id="定义SeqList和LinkList均继承自LinearLis出现的问题"><a href="#定义SeqList和LinkList均继承自LinearLis出现的问题" class="headerlink" title="定义SeqList和LinkList均继承自LinearLis出现的问题"></a>定义SeqList和LinkList均继承自LinearLis出现的问题</h3><p><img src="/2025/03/17/LinearList/对象切割.png" alt="alt text"></p>
<p>使用<strong>引用传递</strong>可以避免对象切割，防止破坏多态性：<br><img src="/2025/03/17/LinearList/引用传递避免对象切割.png" alt="alt text"><br><br></p>
<h3 id="Slicing-Problem-对象切割问题"><a href="#Slicing-Problem-对象切割问题" class="headerlink" title="Slicing Problem 对象切割问题"></a>Slicing Problem 对象切割问题</h3><blockquote>
<p><strong>产生原因</strong>：</p>
<ul>
<li><p>当<mark>把一个派生类对象赋给一个基类对象</mark>时（并不是使用父类指针或引用接收子类对象），会发生对象切割。(另外用<mark>基类对象强制转换派生类对象</mark>也会)<br><img src="/2025/03/17/LinearList/对象切割原因1.png" alt="alt text"><br><br></p>
</li>
<li><p>接收<mark>值传递</mark>的返回值时，发生的拷贝构造也会发生对象切割<br><img src="/2025/03/17/LinearList/对象切割原因2.png" alt="alt text"></p>
</li>
</ul>
</blockquote>
<p><strong><em>发生对象切片后派生类的覆盖部分就被切掉了，所以调用的方法将会是父类方法</em></strong></p>
<p>与对象切割类似的，还有<strong>静态联编</strong>问题：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>&#123;  <span class="comment">//使用virtual关键字声明函数，将其变为虚函数，即可使用多态</span></span><br><span class="line">	 cout &lt;&lt; <span class="string">&quot;基类方法!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	 &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;派生类方法!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Base *ex = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">//静态联编导致子类对象调用基类方法，而不是子类方法</span></span><br><span class="line">	ex-&gt;<span class="built_in">printError</span>(); <span class="comment">//输出基类方法！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">test</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>静态联编</strong>行为：<br>当基类函数<mark>未声明为virtual</mark>时，编译器根据指针/引用的<mark>静态类型（声明类型）</mark><br>决定调用哪个函数。<br>示例中<code>Base* ex</code>的静态类型是<code>Base*</code>，因此<code>ex-&gt;printError()</code>直接调用<code>Base::printError()</code>，即使对象实际是Derived类型。</p>
</blockquote>
<p><strong>单向链表的特点</strong>：</p>
<ol>
<li>可以<mark>灵活改变长度</mark></li>
<li>插入/删除<mark>无需移动</mark>大量数据</li>
<li>通过<mark>指针</mark>表示数据间的顺序关系</li>
<li>表长需要<mark>遍历</mark>获取</li>
<li>插入/删除操作中寻找<mark>相应位置的复杂度高</mark><br><br></li>
</ol>
<h2 id="双向链表——增加前驱指针的单向链表"><a href="#双向链表——增加前驱指针的单向链表" class="headerlink" title="双向链表——增加前驱指针的单向链表"></a>双向链表——增加前驱指针的单向链表</h2><p><img src="/2025/03/17/LinearList/双向链表.png" alt="alt text"><br>对于单向链表，想要获取后继元素，复杂度为$O(1)$,但是想要获取前驱元素，需要遍历，复杂度为$O(n)$<br><strong>双向链表使得两个操作的复杂度都为$O(1)$</strong></p>
<h3 id="双向链表的插入操作"><a href="#双向链表的插入操作" class="headerlink" title="双向链表的插入操作"></a>双向链表的插入操作</h3><p><img src="/2025/03/17/LinearList/双向链表的插入.png" alt="alt text"></p>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>让前驱指向s：</li>
<li><p><code>p -&gt; prev -&gt; next = s</code><br><br></p>
</li>
<li><p>以s为中心，设置它的前驱后继</p>
</li>
<li><code>s -&gt; next = p</code>          </li>
<li><p><code>s -&gt; prev = p -&gt; prev</code><br><br></p>
</li>
<li><p>让后继指向s</p>
</li>
<li><code>p -&gt; prev = s</code></li>
</ul>
<h3 id="双向链表的删除操作"><a href="#双向链表的删除操作" class="headerlink" title="双向链表的删除操作"></a>双向链表的删除操作</h3><p><img src="/2025/03/17/LinearList/双向链表的删除.png" alt="alt text"></p>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>让p的后继往前链接：</li>
<li><p><code>p -&gt; prev -&gt; next = p -&gt; next</code><br><br></p>
</li>
<li><p>让p的前驱往后链接：</p>
</li>
<li><p><code>p -&gt; next -&gt; prev = p -&gt; prev</code><br><br></p>
</li>
<li><p>删除p</p>
</li>
<li><code>delete p</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2025/05/08/Network/</url>
    <content><![CDATA[<h1 id="计算机网络复习"><a href="#计算机网络复习" class="headerlink" title="计算机网络复习"></a>计算机网络复习</h1><p><strong>定义</strong>：多种通用的、可编程硬件互连，支持多种应用<br><img src="/2025/05/08/Network/1.png" alt="alt text"></p>
<p><strong>发展</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>地位</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABC(阿塔纳索夫·贝瑞计算机)</td>
<td>1937</td>
<td>第一台电子数字计算设备，能求解线性方程</td>
</tr>
<tr>
<td>ENIAC</td>
<td>1946</td>
<td>第一台通用电子数字计算机</td>
</tr>
<tr>
<td>ARPANET</td>
<td>1969</td>
<td>多台计算机互联的二代计算机网络</td>
</tr>
<tr>
<td>开放系统互连参考模型(OSI/RM)</td>
<td>1981</td>
<td>全球统一标准，第三代计算机网络</td>
</tr>
<tr>
<td>Internet(互联网)</td>
<td>90年代至今</td>
<td>第四代计算机网络</td>
</tr>
</tbody>
</table>
</div>
<p><strong>互联网与互联网的区别</strong>：<br><img src="/2025/05/08/Network/2.png" alt="alt text"></p>
<p><strong>交换技术</strong>：</p>
<ul>
<li><p>电路交换<br><mark>电路交换必定是面向连接</mark><br><img src="/2025/05/08/Network/3.png" alt="alt text"><br><mark>关键缺点：不适应计算机网络中的突发性，<strong>信道利用率低</strong></mark><br><img src="/2025/05/08/Network/4.png" alt="alt text"></p>
</li>
<li><p>分组交换<br><mark><strong>存储-转发方式</strong></mark><br>具体步骤：构建分组-分别传输-去掉首部-还原报文<br><img src="/2025/05/08/Network/5.png" alt="alt text"><br><img src="/2025/05/08/Network/6.png" alt="alt text"><br><img src="/2025/05/08/Network/7.png" alt="alt text"><br><img src="/2025/05/08/Network/8.png" alt="alt text"><br><img src="/2025/05/08/Network/9.png" alt="alt text"><br>关键缺点：<strong>排队造成时延、首部带来额外开销</strong><br><img src="/2025/05/08/Network/10.png" alt="alt text"></p>
</li>
</ul>
<p><strong>三种交换的比较</strong>：<br><img src="/2025/05/08/Network/11.png" alt="alt text"><br>传输大量数据且<strong>传输时间远大于连接建立时间</strong>，选择电路交换<br>报文交换和分组交换不需要预先分配带宽，<strong>信道利用率更高</strong><br>由于分组的长度小于报文，因此<strong>分组交换比报文交换时延小</strong></p>
<p><strong>端系统通信</strong>：<br><img src="/2025/05/08/Network/12.png" alt="alt text"></p>
<p><strong>C/S方式的特点</strong>：<br>客户程序需要指导服务器程序的地址<br>服务器程序不知道客户程序的地址<br>资源集中在服务器</p>
<p><strong>P2P方式的特点</strong>：<br>不区分请求方和服务提供方<br>资源分散在端系统中</p>
<p><strong>计算机网络的类别</strong>：<br><img src="/2025/05/08/Network/13.png" alt="alt text"><br><img src="/2025/05/08/Network/14.png" alt="alt text"></p>
<p><strong>计算机网络性能指标</strong>：</p>
<ol>
<li><p>速率<br><strong>速率是额定速率，不是实际运行速率</strong><br>单位定义：<br>​bit/s（比特每秒）​：最基础单位，表示每秒传输的1个二进制位（bit）。<br>​kbit/s​（千比特每秒）：<strong>1 kbit/s = ​1,000 bit/s</strong><br>​Mbit/s​（兆比特每秒）：<strong>1 Mbit/s = ​1,000 kbit/s = 10⁶ bit/s</strong><br>​Gbit/s​（吉比特每秒）：<strong>1 Gbit/s = ​1,000 Mbit/s = 10⁹ bit/s</strong><br>​Tbit/s​（太比特每秒）：<strong>1 Tbit/s = ​1,000 Gbit/s = 10¹² bit/s</strong><br><img src="/2025/05/08/Network/15.png" alt="alt text"></p>
</li>
<li><p>带宽<br>频域：频带宽度，单位是赫<br>时域：单位时间内最高数据率，单位是$ bit/s $<br><strong>一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</strong><br><img src="/2025/05/08/Network/16.png" alt="alt text"><br><img src="/2025/05/08/Network/17.png" alt="alt text"></p>
</li>
<li><p>吞吐量<br>表示在单位时间内通过某个网络(或信道、接口)的数据量。<br>吞吐量<strong>受网络的带宽或网络的额定速率的限制，额定速率是绝对上限值</strong>。可能会远小于额定速率，甚至下降到零。</p>
</li>
<li><p>时延<br>包括发送时延、传播时延、处理时延、排队时延<br><img src="/2025/05/08/Network/18.png" alt="alt text"><br><img src="/2025/05/08/Network/19.png" alt="alt text"><br><strong>处理时延</strong>：主机或路由器在收到分组时，为<strong>处理分组</strong>(例如，分析首部、提取数据、差错检验或查找路由)所花费的时间。<br><strong>排队时延</strong>：分组在路由器的接收缓存队列中排队等待接收的时间与在发送缓存队列中排队等待发送所经历的时延之和。<strong>排队时延的长短往往取决于网络中当时的通信量</strong></p>
<blockquote>
<p><strong>注意</strong>:一般不提升传输速率<br><img src="/2025/05/08/Network/20.png" alt="alt text"></p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>例题</strong>：<br><img src="/2025/05/08/Network/21.png" alt="alt text"><br><img src="/2025/05/08/Network/22.png" alt="alt text"></p>
</blockquote>
<ol>
<li><p>时延带宽积<br><img src="/2025/05/08/Network/23.png" alt="alt text"></p>
</li>
<li><p>往返时间（RTT）<br><img src="/2025/05/08/Network/24.png" alt="alt text"><br><strong>不包含发送端的发送时延</strong><br>有效数据率：<br><img src="/2025/05/08/Network/25.png" alt="alt text"></p>
</li>
<li><p>利用率<br><img src="/2025/05/08/Network/26.png" alt="alt text"><br><strong>信道利用率并非越高越好</strong><br><img src="/2025/05/08/Network/27.png" alt="alt text"></p>
</li>
</ol>
<p><strong>协议三要素</strong>：<br><strong>语法</strong>:如何讲，用来规定<strong>信息格式</strong>，涉及数据与控制信息的格式、编码和信号等级(电平的高低)等。<br><strong>语义</strong>:讲什么，用来说明通信双方应该怎么做，涉及<strong>数据的内容、含义及用于协调和差错处理的控制信息</strong>。<br><strong>定时(时序)</strong>:详细说明事件的<strong>先后顺序</strong>，涉及速率匹配和排序等。</p>
<p>协议的功能：分段与重组、封装、连接控制、流量控制、差错控制等</p>
<p><strong>服务原语</strong>：<br><img src="/2025/05/08/Network/28.png" alt="alt text"><br><img src="/2025/05/08/Network/29.png" alt="alt text"></p>
<p><strong>五层协议</strong>：<br><img src="/2025/05/08/Network/30.png" alt="alt text"><br>应用层：通过应用进程间的交互来完成特定网络应用；DNS、HTTP、SMTP；应用层交互的数据单元称为报文</p>
<p>运输层：两台主机中进程之间的通信；分用和复用；TCP和UDP</p>
<p>网络层：为分组交换网上的不同主机提供通信服务；路由选择和转发</p>
<p>链路层：两个相邻节点之间的可靠通信</p>
<p>物理层：实现比特（0 或1）的传输</p>
<h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><p><img src="/2025/05/08/Network/31.png" alt="alt text"></p>
<hr>
<p>传输：任何实际的信道都不是理想的，在传输信号时会产生各种<strong>失真</strong>，而且在信道中也会存在各种<strong>干扰和噪声</strong>。<br><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间的清晰界限的现象。</p>
<hr>
<p><img src="/2025/05/08/Network/32.png" alt="alt text"></p>
<hr>
<h3 id="传输媒介"><a href="#传输媒介" class="headerlink" title="传输媒介"></a>传输媒介</h3><p><strong>有线传输媒介</strong>：</p>
<ol>
<li><p>双绞线<br>绞合度越高，可用的数据传输率越高。<br>无论是哪种类别的双绞线，<strong>衰减都随频率的升高而增大</strong>。</p>
</li>
<li><p>同轴电缆<br>具有很好的<strong>抗干扰</strong>特性，被广泛用于传输<strong>较高速率</strong>的数据</p>
</li>
<li><p>光纤<br><strong>常用的三个波段的中心：0.85um,1.31um,1.55um</strong><br> <strong>单模光纤</strong>：光沿着一条路径传播，若光纤的直径减小到只有一个光的<br>波长（几个微米），则可使光线一直向前传播，而不会产生多次反射。</p>
<p> <strong>多模光纤</strong>：光在多条路径中传播，<strong>光脉冲在多模光纤中传输时会逐渐<br>展宽，造成失真</strong>，只适合于<strong>近距离传输</strong>。</p>
</li>
<li><p>光缆</p>
</li>
</ol>
<p><strong>无线传输媒介</strong>：</p>
<ol>
<li><p><strong>短波通信</strong>（即高频通信）主要是靠<strong>电离层的反射</strong>，但<strong>短波信道的通信质量较差</strong>，传输速率低。<br>微波占有特殊重要的地位，在空间主要是<strong>直线传播</strong>。</p>
</li>
<li><p>微波频率范围：300 MHz~300 GHz（波长1 m ~ 1 mm）；主要使用：2 ~ 40GHz。</p>
</li>
<li><p>传统微波通信有两种方式：地面微波接力通信、卫星通信</p>
</li>
</ol>
<p><strong>2.4GHz频段为各国共同的ISM频段，因此无线局域网、蓝牙、ZigBee等无线网络，均可工作在2.4GHz频段上</strong></p>
<hr>
<h3 id="数据编码与传输"><a href="#数据编码与传输" class="headerlink" title="数据编码与传输"></a>数据编码与传输</h3><p>数据传输技术包括<strong>基带传输</strong>和<strong>频带传输</strong>：</p>
<ul>
<li><strong>基带传输</strong>:数字信号<strong>不做任何改变</strong>直接在信道中进行传输的过程，基带信号没有经过调制，它所占据的频带一般是从<strong>直流或低频开始</strong>的。发送端<strong>编码</strong><mark>（对波形进行变换）</mark>，接收端<strong>解码</strong>。</li>
<li><strong>频带传输</strong>:数字信号<strong>经过调制</strong>后在信道中传输的过程，<mark><strong>调制的目的是减少信号失真，提高线路的利用率</strong></mark>。</li>
</ul>
<h4 id="数字编码方式："><a href="#数字编码方式：" class="headerlink" title="数字编码方式："></a>数字编码方式：</h4><p><img src="/2025/05/08/Network/34.png" alt="alt text"></p>
<p>曼彻斯特码和差分曼彻斯特码产生的<strong>信号频率比不归零码高</strong>。曼彻斯特码和差分曼彻斯特码具有<mark><strong>自同步</strong></mark>能力。</p>
<p><strong>信号码元周期 $T$ 可作为选择信道带宽的主要依据。</strong></p>
<h4 id="模拟传输方式："><a href="#模拟传输方式：" class="headerlink" title="模拟传输方式："></a>模拟传输方式：</h4><p><strong>载波</strong>是一种<strong>由振荡器产生并在通信信道上传输的特定频率的无线电波</strong>，在频率、幅度或相位方面被调制后用于传输话音、图像或其他信息。<br><strong>载波频率通常高于输入信号的频率，属于高频信号。</strong></p>
<p>使用载波把基带信号频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输，<mark><strong>经过载波调制后的信号被称为带通信号</strong></mark></p>
<p><img src="/2025/05/08/Network/35.png" alt="alt text"></p>
<h4 id="模拟信号数字化："><a href="#模拟信号数字化：" class="headerlink" title="模拟信号数字化："></a>模拟信号数字化：</h4><p><strong>实现模拟信号数字化的一种常用方式是脉冲编码调制（PCM）</strong></p>
<p><img src="/2025/05/08/Network/36.png" alt="alt text"></p>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ol>
<li>频分复用（FDM）<br>频分复用要求<mark><strong>总频率宽度大于各个信道频率之和</strong></mark>。各子信道之间设有隔离带，以保证各路信号<strong>互不干扰</strong>。<br>频分复用技术的特点是所有子信道传输的信号以<mark><strong>并行的方式工作</strong></mark>，例如广播、有线电视</li>
</ol>
<p><strong>更多的用户轮流使用这n个频带</strong>，这种方式称为频分多址接入(FDMA)，简称<strong>频分多址</strong>。</p>
<ol>
<li>时分复用（TDM）<br><img src="/2025/05/08/Network/37.png" alt="alt text"><br>同步时分复用是将时间划分为一段段<strong>等长的时分复用帧（TDM帧）</strong>，每一个时分复用的用户在每一个 TDM 帧中占用<strong>固定序号的时隙(同步时分复用)</strong>。<br>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的，TDM信号也称为等时信号。<br><mark><strong>同步时分复用帧的长度是125µs</strong></mark>，<strong>复用的用户越多，每一个用户分配到的时隙宽度就越窄</strong>。<br>同步时分复用的所有用户<strong>在不同的时间占用同样的频带宽度</strong>。</li>
</ol>
<p><strong>更多的用户轮流使用这4个时隙</strong>，这种方式称为时分多址接入（TDMA），简称<strong>时分多址</strong></p>
<p>当某用户暂时无数据发送时，在同步时分复用帧中分配给该用户的时隙只能处于空闲状态。</p>
<ol>
<li><p>统计时分复用（STDM）<br><img src="/2025/05/08/Network/38.png" alt="alt text"><br>数据发往复用器，复用器按顺序扫描，把复用器中的数据放入STDM帧中，一个STDM帧满了就发出去。<br><strong>STDM不是固定分配时隙，而是按需动态分配时隙</strong>。因此统计时分复<br>用可以<strong>提高线路的利用率</strong>。<br>注意：<strong>STDM帧的时隙数少于终端数</strong>，并且有站标识开销。</p>
</li>
<li><p>波分复用（WDM）<br><img src="/2025/05/08/Network/39.png" alt="alt text"><br><strong>光的波分复用可以理解为光的频分复用</strong>。<br><strong>可以是单向传输，也可以是双向传输</strong>。</p>
</li>
<li><p>码分复用（CDM）<br>每一个用户可以在<strong>同样的时间使用同样的频带</strong>进行通信，使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br><strong>当码分复用（CDM）信道为多个不同地址的用户所共享时，就称为码分多址（CDMA）</strong>。<br><strong>每一个比特时间划分为 m 个短的间隔，称为码片</strong>，通常m的值是64或128。</p>
</li>
</ol>
<p><strong>码片序列：</strong><br><img src="/2025/05/08/Network/40.png" alt="alt text"><br><strong>-1 表示 0，+1 表示 1</strong></p>
<p><strong>码片序列实现了扩频</strong>:假定S站要发送信息的数据率为 b $bit/s$。由于每一个比特要转换成 m 个比特的码片，因此S站实际上发送的数据率提高到 mb $bit/s$，同时S站所占用的频带宽度也提高到原来数值的 m 倍</p>
<p><strong>CDMA的重要特点</strong>：每个站分配的码片序列：<strong>各不相同，且必须互相正交。</strong><br><img src="/2025/05/08/Network/41.png" alt="alt text"></p>
<p><strong>总结</strong>：</p>
<ul>
<li>频分复用:不同用户，相同时间，不同频带</li>
<li>同步时分复用:不同用户，不同时间，相同频带</li>
<li>统计时分复用:解决信道利用率低的问题</li>
<li>波分复用:不同用户，相同时间，不同波长</li>
<li>码分复用：不同用户，相同时间，相同频带，不同码型</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>考虑的是怎样才能在连接各种计算机的传输媒介上<strong>传输数据比特流，而不是指具体的传输媒介</strong>。从逻辑角度看，<strong>物理层是传输媒介与数据链路层之间的接口</strong>。</p>
<p><strong>标准化的DTE/DCE接口具有的特性</strong>：</p>
<ul>
<li><strong>机械特性</strong>：对接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等作出详细的规定。</li>
<li><strong>电气特性</strong>：规定了DTE/DCE之间多根信号线的电气连接及有关电路特性。通常包括发送器和接收器的电路特性。</li>
<li><strong>功能特性</strong>：描述接口执行的功能，定义接线器的每一引脚(针，Pin)的作用</li>
<li><strong>规程特性</strong>：规定了DTE/DCE接口各信号线之间的相互关系、工作顺序和时序，以及维护测试操作等内容。<strong>反映了通信双方在数据通信过程中可能发生的各种事件。</strong></li>
</ul>
<p><strong>宽带接入技术</strong>：</p>
<ol>
<li>ADSL技术<br>非对称数字用户线ADSL (Asymmetric Digital Subscriber Line) 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。<br><strong>非对称：下行（从ISP 到用户）带宽远大于上行（从用户到ISP）带宽</strong><br>ADSL 技术就把 0~4 $kHz$ 低端频谱留给传统电话使用，而<strong>把原来没有被利用的高端频谱留给用户上网使用</strong>。<br>ADSL 最大好处是可以利用现有电话网中的用户线（铜线），而不需要重新布线，节省了大量投资。<br><strong>ADSL 并不适合于企业，因为企业往往需要使用上行信道发送大量数据给许多用户。</strong></li>
</ol>
<p><img src="/2025/05/08/Network/42.png" alt="alt text"><br><mark><strong>DMT</strong></mark> 调制技术采用<strong>频分复用</strong>的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多<strong>子信道</strong>，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。<strong>每个子信道占据 4 kHz 带宽（严格讲是4.3125 kHz）</strong>，并使用<strong>不同的载波</strong>进行数字调制。</p>
<ol>
<li><p>HFC技术<br>HFC网是在原有覆盖面很广的有线电视网CATV 的基础上开发的一种居民宽带接入网，将原 CATV 网中的同轴电缆<strong>主干部分改换为光纤</strong>，并使用模拟光纤技术，除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p>
</li>
<li><p>FTTx 技术<br>FTTx 是一种实现宽带居民接入网的方案，代表<strong>多种宽带光纤接入方式</strong><br><img src="/2025/05/08/Network/43.png" alt="alt text"></p>
</li>
</ol>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p><img src="/2025/05/08/Network/44.png" alt="alt text"><br><strong>数据链路层实现是相邻节点之间的通信，为网络层实现的主机之间的通信提供了支持。</strong></p>
<p>数据链路层信道类型包括<strong>点对点信道</strong>和<strong>广播信道</strong></p>
<p><strong>数据链路</strong>：链路加上实现通信协议的硬件和软件就构成了数据链路。</p>
<p><img src="/2025/05/08/Network/45.png" alt="alt text"></p>
<p><strong>帧：数据链路层的协议数据单元</strong><br><img src="/2025/05/08/Network/46.png" alt="alt text"></p>
<p><strong>数据链路层的主要功能</strong>：数据链路的建立、拆除和管理；封装成帧；透明传输；差错控制；流量控制。<br>数据链路层的协议有很多种，但不论哪种协议，都必须解决以下三个基本问题：<strong>封装成帧、透明传输、差错检测</strong></p>
<p><strong>封装成帧就是在一段数据的前后分别添加首部和尾部</strong>，然后就构成了一个帧。首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。<br><mark><strong>最大传送单元 MTU</strong>：规定了所能传送的帧的数据部分长度上限。</mark><br><img src="/2025/05/08/Network/47.png" alt="alt text"></p>
<ol>
<li><p>封装成帧<br>控制字符 SOH 放在一帧的最前面，表示帧的首部开始；控制字符 EOT 表示帧的结束。<br><img src="/2025/05/08/Network/48.png" alt="alt text"></p>
</li>
<li><p>透明传输<br>在数据链路层透明传送数据，表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。<br><strong>避免错误找到帧边界：</strong><br><img src="/2025/05/08/Network/49.png" alt="alt text"></p>
</li>
<li><p>差错检测<br>传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1 。</p>
</li>
</ol>
<p>通常用误比特率或误码率 <strong>（在一段时间内传输错误的⽐特数占所传输⽐特总数的比率）</strong> 来衡量通信链路的质量。</p>
<p><strong>循环冗余校验（CRC）原理</strong><br><img src="/2025/05/08/Network/50.png" alt="alt text"><br><img src="/2025/05/08/Network/51.png" alt="alt text"></p>
<p><strong>在数据后面添加上的冗余码称为帧检验序列 FCS</strong><br><mark><strong>循环冗余检验CRC 和帧检验序列 FCS 并不等同：</strong></mark></p>
<ul>
<li>CRC 是一种常用的<strong>检错方法</strong>，而FCS 是添加在数据后面的<strong>冗余码</strong>。</li>
<li>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得FCS 的唯一方法。</li>
</ul>
<p><mark>仅用循环冗余检验 CRC 技术<strong>只能做到无差错接收</strong>。</mark></p>
<ul>
<li>“无差错接收”是指：“凡是接收的帧（即<strong>不包括丢弃的帧</strong>），我<br>们都能以非常接近于1 的概率认为“凡是接收端数据链路层接收的帧都没有传输差错”<strong>（有差错的帧就丢弃而不接收）</strong>。</li>
</ul>
<blockquote>
<p><strong>注意：</strong><br>单纯使用 CRC 差错检测技术<strong>不能实现“无差错传输”或“可靠传输”</strong><br>应当明确，<strong>“无比特差错”与“无传输差错”是不同的概念</strong><br>在数据链路层使用CRC 检验，<strong>能够实现无比特差错的传输，但这还不是可靠传输</strong><br>要做到“无差错传输”（即发送什么就收到什么）就必须再加上<strong>确认和重传机制</strong></p>
</blockquote>
<h3 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h3><p><strong>点对点协议（PPP）</strong><br>PPP协议<strong>不需要的功能</strong>包括： <strong>纠错、流量控制、设置序号、多点线路、半双工或单工链路</strong></p>
<p>PPP非常简单：每收到一个帧，进行CRC检验，如果CRC检验正确，就接收这个帧；反之，就丢弃这个帧，其他什么也不做。</p>
<p>PPP的应用场景：<br><img src="/2025/05/08/Network/52.png" alt="alt text"></p>
<p>PPP由三个部分组成：</p>
<ul>
<li><strong>一个将 IP 数据报封装到串行链路的方法</strong></li>
<li><strong>链路控制协议 LCP</strong>，用来建立、配置和测试链路，其最重要的功能之一是身份验证(PAP，CHAP)</li>
<li><strong>网络控制协议NCP</strong>，支持不同的网络层协议</li>
</ul>
<p>PPP的帧格式：<br><img src="/2025/05/08/Network/53.png" alt="alt text"><br><strong>PPP 是面向字节的，所有的PPP 帧的长度都是整数字节。</strong></p>
<p>PPP的透明传输问题</p>
<ul>
<li>当 PPP 用在<strong>异步传输</strong>时，就使用一种特殊的<strong>字节填充法</strong>。</li>
<li>当 PPP 用在<strong>同步传输</strong>时，协议规定<strong>采用硬件来完成比特填充</strong>。</li>
</ul>
<p>字节填充法：<br><img src="/2025/05/08/Network/54.png" alt="alt text"><br><strong>注意：第六位指的是从后向前数六位，0x21是十六进制，所以其二进制表示为00100001</strong></p>
<p>零比特填充：<br><img src="/2025/05/08/Network/55.png" alt="alt text"></p>
<p>PPP的工作过程：<strong>PPP 协议不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容</strong><br><img src="/2025/05/08/Network/56.png" alt="alt text"></p>
<p>口令鉴别协议（PAP）：<br><strong>两次握手</strong>鉴别协议，口令以<strong>明文</strong>传送，<strong>被鉴别方首先发起鉴别请求</strong></p>
<p>质询握手鉴别协议（CHAP）：<br><strong>三次握手</strong>鉴别协议，<strong>主鉴别方首先发起鉴别请求</strong>，<mark>安全性比PAP高</mark></p>
<h3 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h3><p><strong>局域网的数据链路层</strong><br><strong>MAC地址</strong>：<br><img src="/2025/05/08/Network/57.png" alt="alt text"></p>
<p><strong>以太网帧</strong>：<br>最常用的 MAC 帧是 <strong>EthernetⅡ</strong> 的格式：<br><img src="/2025/05/08/Network/58.png" alt="alt text"><br><strong>当数据字段的长度小于 46 字节时</strong>，应在数据字段的后面加入整数字节的填充字段，<strong>以保证以太网的 MAC 帧长不小于64 字节</strong></p>
<p>前同步码和帧开始定界符：<br><img src="/2025/05/08/Network/59.png" alt="alt text"></p>
<p><strong>无效的 MAC 帧</strong></p>
<ul>
<li><strong>数据字段的长度与长度字段的值</strong>不一致；</li>
<li>帧的长度不是<strong>整数</strong>个字节；</li>
<li>用收到的帧检验序列 <strong>FCS 查出有差错</strong>；</li>
<li>数据字段的长度<strong>不在46 ~ 1500 字节之间</strong>。<br><strong>对于检查出的无效MAC 帧就简单地丢弃，以太网不负责重传丢弃的帧。</strong></li>
</ul>
<p><strong>“网卡”（通信适配器）</strong><br><img src="/2025/05/08/Network/60.png" alt="alt text"><br>每收到一个 MAC 帧就<strong>先用硬件检查 MAC 帧中的 MAC 地址</strong>。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p>
<p><strong>“发往本站的帧”包括以下三种帧：</strong></p>
<ul>
<li>单播帧（一对一）</li>
<li>广播帧（一对全体）</li>
<li>多播帧（一对多）</li>
</ul>
<p><img src="/2025/05/08/Network/61.png" alt="alt text"><br><strong>解决方法：动态媒体接入控制（多点接入）</strong></p>
<ul>
<li><strong>随机接入</strong>：所有用户可随机发送信息。</li>
<li><strong>受控接入</strong>：用户必须服从一定的控制。如<strong>集中控制的多点线路探询，或轮询</strong>。</li>
</ul>
<p><strong>以太网采取了两种重要措施：<mark>采用较为灵活的无连接工作方式</mark></strong></p>
<ul>
<li><strong>不必建立连接</strong>就可以直接发送数据。</li>
<li>对发送的数据帧<strong>不进行编号，也不要求对方发回确认</strong>。</li>
</ul>
<p><strong>以太网发送的数据都使用曼彻斯特编码</strong><br><img src="/2025/05/08/Network/62.png" alt="alt text"></p>
<p><strong>CAMA/CD 协议（载波监听多址接入/碰撞检测）</strong><br><img src="/2025/05/08/Network/63.png" alt="alt text"></p>
<blockquote>
<p><strong>为什么要进行碰撞检测？</strong><br><mark><strong>因为信号传播时延对载波监听产生了影响</strong></mark><br><img src="/2025/05/08/Network/64.png" alt="alt text"></p>
</blockquote>
<p><strong>CSMA/CD：争用期</strong><br><strong>以太网的端到端往返时延 2t 称为争用期或碰撞窗口</strong>。经过争用期这段时间还未检测到碰撞，才能确定这次发送不会发生碰撞。<br><strong>无效帧：</strong> 10Mbit/s 以太网取 51.2 μs 为争用期的长度，对于 10Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。如果发生碰撞，就一定是在发送的前 64 字节之内。 由于一检测到碰撞就立即中止发送，这时已经发送出去的数据一定<strong>小于 64 字节</strong>。<mark><strong>以太网规定了最短有效帧长为 64 字节</strong></mark>，凡长度小于 64 字节的帧都是由于碰撞而异常中止的无效帧。</p>
<p><strong>CSMA/CD：5-4-3规则</strong><br><img src="/2025/05/08/Network/65.png" alt="alt text"></p>
<p><strong>CSMA/CD：检测到碰撞后如何操作？</strong><br>每一个正在发送数据的站，<strong>一旦发现总线上出现碰撞，适配器就要立即停止发送</strong>，免得继续浪费网络资源，然后<strong>等待一段随机时间后再次发送</strong>。</p>
<p><strong>CSMA/CD：碰撞后重传的时机</strong><br><strong>截断二进制指数退避算法：</strong><br>规定发生碰撞的站点在停止发送数据后，要推迟（退避）一个<strong>随机时间</strong>才能再发送数据。</p>
<ul>
<li><strong>基本退避时间取为争用期 2t。</strong></li>
<li>定义重传次数 $k$ ，$k = Min[重传次数, 10]$<ul>
<li>从整数集合 $[0, 1, … , (2^k - 1)]$ 中随机地取出一个数，记为 r ,则<strong>重传所需的时延就是 r 倍的基本退避时间</strong>。</li>
</ul>
</li>
<li><strong>当重传达 16 次仍不能成功时即丢弃该帧</strong>，并向高层报告。</li>
<li>该算法可以<mark><strong>使重传需要推迟的平均时间随重传次数的增多而增大（也称为动态退避）</strong></mark>，从而减小了发生碰撞的概率，有利于整个系统的稳定。</li>
</ul>
<p><strong>CSMA/CD：人为干扰信号</strong></p>
<ul>
<li>发生碰撞后，发送端需<strong>强化碰撞</strong>。</li>
<li>立即停止发送数据，再继续发送<strong>若干比特(32bit、48bit或64bit)的人为干扰信号</strong>，让所有用户都知道发生了碰撞。</li>
<li>以太网还规定了<mark><strong>帧间最小间隔为9.6 μs</strong></mark></li>
</ul>
<p><strong>使用 CSMA/CD 协议时，各站点<mark>不能进行全双工通信而只能进行双向交替通信（半双工通信）</mark>，这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</strong></p>
<p><strong>以太网的信道利用率</strong><br><strong>参数 $a$</strong><br><img src="/2025/05/08/Network/66.png" alt="alt text"><br><strong>注意：</strong></p>
<ul>
<li>数据率一定时，以太网的连线的长度要有限制，否则 t 的数值会太大。</li>
<li>以太网的帧长不能太短，否则 $T_0$ 的值会太小，使 $a$ 值太大。</li>
</ul>
<p><strong>极限信道利用率</strong><br><img src="/2025/05/08/Network/67.png" alt="alt text"></p>
<p><strong>CSMA/CD 和 CSMA/CA的对比</strong><br><img src="/2025/05/08/Network/68.png" alt="alt text"></p>
<h3 id="扩展局域网"><a href="#扩展局域网" class="headerlink" title="扩展局域网"></a>扩展局域网</h3><p><strong>网络中的中介设备</strong><br><img src="/2025/05/08/Network/69.png" alt="alt text"></p>
<p><strong>集线器</strong><br><strong>在利用集线器组建的局域网中，所有计算机都处于<mark>同一个碰撞域（或冲突域）中和同一个广播域中。</mark></strong><br><strong>碰撞域增大，但总吞吐量并未提高</strong><br><img src="/2025/05/08/Network/70.png" alt="alt text"></p>
<p><strong>网桥</strong><br><img src="/2025/05/08/Network/71.png" alt="alt text"></p>
<p><strong>交换机</strong><br>本质上是多端口网桥、全双工工作<br><img src="/2025/05/08/Network/72.png" alt="alt text"><br><strong>每个端口都处于一个独立的碰撞域（或冲突域）中，但所有计算机都处于同一个广播域中。</strong><br><img src="/2025/05/08/Network/73.png" alt="alt text"></p>
<p><strong>集线器和交换机的区别</strong><br><img src="/2025/05/08/Network/74.png" alt="alt text"><br><img src="/2025/05/08/Network/75.png" alt="alt text"></p>
<p><strong>交换机的自学习功能</strong><br><img src="/2025/05/08/Network/76.png" alt="alt text"><br><img src="/2025/05/08/Network/77.png" alt="alt text"><br><img src="/2025/05/08/Network/78.png" alt="alt text"></p>
<p><strong>广播风暴</strong><br>由于一直学习不到E的地址，S1和S2之间会无限循环泛洪，造成广播风暴。<br><img src="/2025/05/08/Network/79.png" alt="alt text"><br><strong>解决办法：生成树协议</strong><br>不改变网络的实际拓扑，但在<strong>逻辑上则切断了某些链路</strong>，使得从一台主机到所有其他主机的路径是无环路的树状结构</p>
<p><strong>虚拟局域网（VLAN）</strong><br>虚拟局域网（VLAN）<strong>只是局域网给用户提供的一种服务</strong>，而并不是一种新型局域网。<br><strong>划分VLAN的主要作用是隔离广播域，增强网络的安全性和管理。</strong><br>VLAN限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息（即“广播风暴”）而降低性能。<br><img src="/2025/05/08/Network/80.png" alt="alt text"></p>
<p><strong>VLAN的划分方法包括：</strong></p>
<ul>
<li>基于交换机端口</li>
<li>基于MAC地址</li>
<li>基于协议类型</li>
<li>基于IP子网地址</li>
<li>基于高层应用或服务</li>
</ul>
<p><strong>地址解析协议（ARP）</strong><br>IP数据报交付到主机或路由器需要<strong>两级地址：IP地址和物理地址</strong></p>
<blockquote>
<p><strong>为什么需要使用IP地址？</strong></p>
<ul>
<li>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。<strong>要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作。</strong></li>
<li>IP 编址把这个复杂问题解决了。<strong>通过在物理网络上覆盖一层IP软件来实现对物理地址差异性的屏蔽</strong>，为上层用户提供“统一”的地址形式，而且不对物理地址做任何修改。</li>
</ul>
</blockquote>
<p><strong>ARP的工作原理</strong><br><img src="/2025/05/08/Network/81.png" alt="alt text"></p>
<p><strong>ARP高速缓存技术</strong><br><strong>每一个主机都设有一个 ARP 高速缓存区，用来存放最近使用的 IP 地址到物理地址之间的映射记录。</strong><br>为了保证主机中 ARP 表的正确性和有效性，ARP 表要经常更新。采用 ARP 高速缓存技术可以提高网络运行的效率。<br><img src="/2025/05/08/Network/82.png" alt="alt text"></p>
<p><strong>ARP命令</strong><br><img src="/2025/05/08/Network/83.png" alt="alt text"><br><img src="/2025/05/08/Network/84.png" alt="alt text"><br><img src="/2025/05/08/Network/85.png" alt="alt text"></p>
<blockquote>
<p><strong>点对点链路不使用ARP协议</strong><br>因为在设置这些链路时，网络设备已获得了链路两端的IP地址</p>
</blockquote>
<p><strong>特殊的ARP</strong></p>
<ol>
<li>代理ARP<br><img src="/2025/05/08/Network/86.png" alt="alt text"></li>
<li>免费ARP<br>主机发送 ARP 广播来查找自己的IP地址，一般发生在<strong>局域网IP地址冲突时，地址修改或变更时</strong>，DHCP分发地址时，ARP缓存表清理时，用来获取网络接口的MAC地址</li>
</ol>
<p><strong>ARP欺骗攻击</strong><br><strong>本质上都是通过<mark>填写错误的IP-MAC对应关系</mark>来实现的</strong></p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><strong><em>网络层提供不可靠、无连接、尽力而为的<mark>数据报</mark>传送服务。</em></strong><br><strong><em>主机运输层负责可靠交付。</em></strong></p>
<p><strong>虚电路和数据报的区别：</strong><br><img src="/2025/05/08/Network/87.png" alt="alt text"></p>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>网际协议（IP）<strong>是 TCP/IP 协议族中最为核心的协议</strong>，提供的是不可靠、无连接、尽力而为的数据报传送服务。</p>
<h4 id="IPv4-数据报格式"><a href="#IPv4-数据报格式" class="headerlink" title="IPv4 数据报格式"></a>IPv4 数据报格式</h4><p>一个 IPv4 数据报由<strong>首部和数据</strong>两部分组成。<br>首部的前一部分<strong>是固定长度，共 20 字节</strong>，是所有IPv4 数据报必须具有的。<br><img src="/2025/05/08/Network/88.png" alt="alt text"></p>
<ul>
<li><p>版本——占4位，指 IP 协议的版本。</p>
</li>
<li><p>首部长度——占4位，可表示的最大数值是15个单位(一个单位为 4 字节)，因此<strong>IP 的首部长度的最大值是 60 字节</strong>。如果数据报的首部长度<strong>不是<mark>4字节的整数倍</mark>，必须利用最后的填充字段加以填充。</strong></p>
</li>
<li><p>区分服务——占8位，用来获得更好的服务<br><img src="/2025/05/08/Network/89.png" alt="alt text"></p>
<ul>
<li><strong>DSCP（差分服务代码点）</strong>：用于标识不同的服务类别或优先级。为不同类型的流量<strong>提供不同的服务质量（QoS）保障。</strong></li>
<li><strong>ECN （显式拥塞通告）</strong>：用于在网络出现拥塞时，向发送方发送拥塞通知。取值0 表示不支持ECN，1 表示支持ECN 且当前网络无拥塞，2 表示支持ECN 且网络出现拥塞，3 保留未用。</li>
</ul>
</li>
<li><p>总长度——占 16 位，<strong>指首部和数据之和的长度</strong>，单位为字节，因<br>此数据报的最大长度为 65535 字节。<strong>总长度必须不超过数据链路层<br>的最大传送单元MTU。</strong></p>
</li>
</ul>
<p><strong><em>标识、标志、片偏移与IP分片有关，IP数据报总长度超过MTU时，IP数据报需要分片。</em></strong></p>
<ul>
<li><p>标识——占16位，是一个计数器，用来产生IP数据报的标识，通常每发送一份报文它的值就会加1。当数据报长度超过网络的MTU而必须分片时，标识字段的值就被复制到所有的数据报片的标识字段中，<strong>相同的标识字段值使分片后的各数据报片最后能正确地重组为原来的数据报。</strong></p>
</li>
<li><p>标志——占3位，目前只有两位有意义。标志字段中的最低位记为MF（More Fragment），<strong>MF=1表示后面还有分片的数据；MF=0表示最后一个数据报片</strong>。标志字段中间的一位记为DF（Don’t Fragment），其含义是不能分片（DF=1），<strong>只有当DF=0时才允许分片。</strong></p>
</li>
<li><p>片偏移——占13位，指出较长的分组在分片后<strong>某片在原分组中的相对位置</strong>，即相对于用户数据字段的起点，该片从何处开始。<strong>以<mark>8个字节为偏移单位</mark>，即每个分片的长度一定是8字节（64bit）的整数倍。</strong></p>
</li>
</ul>
<p><strong>除最后一个分片外，<mark>每个分片的数据长度必须是8的倍数</mark></strong><br><img src="/2025/05/08/Network/90.png" alt="alt text"><br><img src="/2025/05/08/Network/91.png" alt="alt text"></p>
<ul>
<li><p>生存时间——占8位，记为TTL，由发出数据报的源主机设置这个字段，<strong>指示数据报在网络中可通过的路由器数的最大值</strong>。TTL的初始值通常设为32或64，每经过一个路由器，其值就减去1。当TTL=0时，丢弃数据报，并发送ICMP报文通知源主机。</p>
</li>
<li><p>协议——占8位，指出此数据报携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给那个处理过程</p>
</li>
<li><p>首部校验和——占16位，<strong>只校验数据报的首部，不校验数据部分</strong>。IP数据报首部校验和的计算采用<strong>16位二进制反码求和算法</strong>。<br><img src="/2025/05/08/Network/92.png" alt="alt text"></p>
</li>
<li><p>源地址和目的地址——源地址和目的地址都各占4字节。</p>
</li>
<li><p>可选字段——长度可变，从1个字节到40个字节不等</p>
</li>
<li><p>填充——使IP数据报为<strong>4字节的整数倍。</strong></p>
</li>
</ul>
<blockquote>
<p><strong>为什么只检验首部，不检验数据部分？</strong><br>网络层（IP）的职责是<strong>尽力而为的传输，而端到端可靠性由传输层（如TCP）保证。</strong>首部校验确保路由基础正确，但数据完整性由更高层协议负责。</p>
</blockquote>
<h4 id="IPv4-地址"><a href="#IPv4-地址" class="headerlink" title="IPv4 地址"></a>IPv4 地址</h4><p><img src="/2025/05/08/Network/93.png" alt="alt text"></p>
<p><strong>点分十进制记法</strong><br><img src="/2025/05/08/Network/94.png" alt="alt text"></p>
<p><strong>各类IP地址</strong><br><img src="/2025/05/08/Network/95.png" alt="alt text"><br><img src="/2025/05/08/Network/96.png" alt="alt text"></p>
<blockquote>
<p>最大可指派的网络数计算逻辑如下：<br>​A类网络计算逻辑<br>​网络位结构：A类地址第一个字节固定最高位为0，剩余7位为网络位<br><strong>0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</strong><br>​理论网络数：$2^7 = 128$<br>​实际可指派数：<br>网络号0.0.0.0（全0）被保留为默认路由<br>网络号127.x.x.x被保留为环回地址（如127.0.0.1）<br>⇒ ​公式：$2^7 - 2 = 126$</p>
<p>​B类网络计算逻辑<br>​网络位结构：B类地址前两个字节最高位固定为10，剩余14位为网络位<br><strong>10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</strong><br>​理论网络数：$2^{14} = 16384$<br>​实际可指派数：<br>网络号128.0.0.0是第一个有效网络号<br>网络号191.255.0.0是最后一个有效网络号<br>⇒ ​公式：$2^{14} - 1 = 16383$</p>
<p>​C类网络计算逻辑<br>​网络位结构：C类地址前三个字节最高位固定为110，剩余21位为网络位<br><strong>110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</strong><br>​理论网络数：$2^{21} = 2,097,152$<br>​实际可指派数：<br>网络号192.0.1.0是第一个有效网络号<br>网络号223.255.255.0是最后一个有效网络号<br>⇒ ​公式：$2^{21} - 1 = 2,097,151$</p>
</blockquote>
<p><strong>127.x.x.x被保留为环回地址（如127.0.0.1）</strong></p>
<h4 id="解决IPv4地址匮乏的方法：划分子网和构造超网"><a href="#解决IPv4地址匮乏的方法：划分子网和构造超网" class="headerlink" title="解决IPv4地址匮乏的方法：划分子网和构造超网"></a>解决IPv4地址匮乏的方法：划分子网和构造超网</h4><p><strong>划分子网</strong><br><img src="/2025/05/08/Network/97.png" alt="alt text"></p>
<p>子网掩码可用与IP地址格式相同的点分十进制表示</p>
<ul>
<li>例如：255.255.255.0，255.255.255.126</li>
</ul>
<p>也可在IP地址后加上“/”符号和1-32的数字，其中1-32的数字表示子网掩码中网络标识位的长度</p>
<ul>
<li>例如：192.168.0.1/24（ 255.255.255.0 ）<br><img src="/2025/05/08/Network/98.png" alt="alt text"></li>
</ul>
<p><strong>子网掩码的作用</strong></p>
<ol>
<li>使用子网掩码可以确定子网的网络地址</li>
<li><strong>决定子网中主机的数目</strong><br><img src="/2025/05/08/Network/99.png" alt="alt text"></li>
</ol>
<p><strong>注意：</strong><br><strong><mark>相同的IP地址和不同的子网掩码可以得到相同的网络地址。</mark></strong><br><strong>不同的子网掩码可以使同一网络划分的子网数和每个子网中的最大主机数都不同。</strong></p>
<p><img src="/2025/05/08/Network/100.png" alt="alt text"></p>
<p><strong>构造超网</strong><br><strong>无分类域间选路（CIDR）</strong><br>两级编址：<br><img src="/2025/05/08/Network/101.png" alt="alt text"><br><img src="/2025/05/08/Network/102.png" alt="alt text"></p>
<p>地址块：<br><img src="/2025/05/08/Network/103.png" alt="alt text"></p>
<blockquote>
<p><strong>​全0地址（如128.14.32.0）的保留意义</strong><br>这是CIDR地址块的<strong>网络标识地址，用于表示整个子网本身。</strong><br><strong>​全1地址（如128.14.47.255）的保留意义</strong><br>这是CIDR地址块的<strong>广播地址</strong>，用于向子网内所有设备发送广播数据包。</p>
</blockquote>
<p>特殊的地址块：<br><img src="/2025/05/08/Network/104.png" alt="alt text"></p>
<blockquote>
<p><strong>一个CIDR 地址块可以表示很多地址，这种地址的聚合常称为<mark>路由聚合 (构成超网)</mark></strong></p>
<p><strong>CIDR可以看作是子网划分的逆过程</strong></p>
<ul>
<li>使用CIDR技术聚合地址时，<strong>网络前缀越短，其地址块所包含的地址数就越多。</strong></li>
<li><strong>划分子网是使网络前缀变长</strong>。</li>
</ul>
</blockquote>
<p><strong>最长前缀匹配</strong><br>在查找路由表时可能会得到不止一个匹配结果，应从匹配结果中<strong>选择具有最长网络前缀的路由</strong>，<mark>网络前缀越长，其地址块就越小，路由就越具体。</mark><br><img src="/2025/05/08/Network/105.png" alt="alt text"></p>
<p><img src="/2025/05/08/Network/106.png" alt="alt text"></p>
<p><img src="/2025/05/08/Network/107.png" alt="alt text"></p>
<h4 id="IPv6-数据报格式"><a href="#IPv6-数据报格式" class="headerlink" title="IPv6 数据报格式"></a>IPv6 数据报格式</h4><p><img src="/2025/05/08/Network/108.png" alt="alt text"><br>变化：<br>首部长度：<strong>固定的40字节，称为基本首部</strong><br>首部字段数：只有<strong>8个</strong>。</p>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p><strong>冒号十六进制记法</strong><br>每个 16 位的值用十六进制值表示，各值之间用冒号分隔。<br><img src="/2025/05/08/Network/109.png" alt="alt text"></p>
<p><strong>零省略和零压缩</strong><br><img src="/2025/05/08/Network/110.png" alt="alt text"></p>
<p><mark><strong><em>注意：在任一地址中只能使用一次零压缩。</em></strong></mark><br><img src="/2025/05/08/Network/111.png" alt="alt text"></p>
<p><strong>特殊的地址</strong><br><img src="/2025/05/08/Network/112.png" alt="alt text"></p>
<h3 id="IP选路"><a href="#IP选路" class="headerlink" title="IP选路"></a>IP选路</h3><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>典型的网络层设备，其任务是<strong>连通不同的网络，转发分组</strong>。</p>
<ul>
<li>端口：配置端口、局域网端口、广域网端口</li>
<li>结构：路由选择处理机、分组处理与交换部分<br><img src="/2025/05/08/Network/113.png" alt="alt text"></li>
</ul>
<p><strong>路由选择和转发的区别</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比维度</th>
<th>​路由选择</th>
<th>​转发</th>
</tr>
</thead>
<tbody>
<tr>
<td>​动态性</td>
<td>动态调整（适应拓扑变化）</td>
<td>静态执行（基于现有转发表）</td>
</tr>
<tr>
<td>​范围</td>
<td>全局网络路径规划</td>
<td>局部数据包传送</td>
</tr>
<tr>
<td>​设备协作</td>
<td>多路由器协同工作</td>
<td>单路由器独立操作</td>
</tr>
<tr>
<td>​信息粒度</td>
<td>逻辑地址（IP层）</td>
<td>物理接口（端口/MAC地址）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>路由表</strong><br><img src="/2025/05/08/Network/114.png" alt="alt text"></p>
<p><strong>IP路由选择的顺序: 主机路由、网络路由、默认路由</strong><br><img src="/2025/05/08/Network/115.png" alt="alt text"></p>
<h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><p>路由选择协议属于<strong>网络层控制层面</strong>的内容<br><img src="/2025/05/08/Network/116.png" alt="alt text"></p>
<p><strong>分层的路由选择协议</strong><br>把整个互联网划分为许多较小的<strong>自治系统AS</strong>，采用分层的路由选择协议。</p>
<ul>
<li>分为2个层次：域内和域间的路由选择</li>
</ul>
<p><strong>OSPF协议</strong><br><img src="/2025/05/08/Network/118.png" alt="alt text"></p>
<p><strong>区域：</strong><br><img src="/2025/05/08/Network/117.png" alt="alt text"></p>
<p><strong>作用：</strong><br><strong>减少了网络上的通信量；减少了需要维护的状态数量。</strong></p>
<p><strong>相邻路由器和相邻关系的区别：</strong><br>相邻路由器指的是两台通过一条<strong>普通链路相连的、可以对话的路由器</strong>。<br>相邻关系指的是两台相邻路由器的<strong>双向关系</strong>。<br><mark><strong>注意：是邻居不一定就有相邻关系。</strong></mark></p>
<p><strong>链路状态数据库和链路状态广播：</strong><br><strong>链路状态数据库（LSDB）</strong><br>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个LSDB，它实际上是<strong>全网的拓扑结构图，在全网范围内是一致的（这称为链路状态数据库的同步）</strong>。<br><strong>链路状态广播（LSA）</strong><br>每台路由器根据自己周围的网络拓扑结构生成LSA，<strong>通过相互之间发送协议报文将LSA发送给网络中其他路由器</strong>，这样每台路由器都收到了其他路由器的LSA，<strong>所有的LSA放在一起便组成了LSDB</strong>。</p>
<p><strong>报文类型：</strong><br><img src="/2025/05/08/Network/119.png" alt="alt text"><br><img src="/2025/05/08/Network/120.png" alt="alt text"></p>
<h4 id="互联网控制报文协议（ICMP）"><a href="#互联网控制报文协议（ICMP）" class="headerlink" title="互联网控制报文协议（ICMP）"></a>互联网控制报文协议（ICMP）</h4><p>ICMP是TCP/IP协议族的一个子协议，属于<strong>网络层协议</strong>，主要用于在<strong>主机与路由器之间传递控制消息</strong>。</p>
<blockquote>
<p><strong>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息</strong>。这些控制消息虽然并不传输用户数据，但是对于<strong>用户数据的传递和网络安全</strong>具有极其重要的意义。</p>
</blockquote>
<p><strong>ICMP 报文格式</strong><br><strong>ICMP报文的前4个字节是统一的格式</strong>，共有三个字段：类型、代码和校验和。接着的4个字节的内容与ICMP的类型有关。<br><img src="/2025/05/08/Network/121.png" alt="alt text"></p>
<p><strong>ICMP 报文类型</strong><br>差错报文和查询报文</p>
<p><strong>ICMP差错报文弥补了IP协议的不可靠问题</strong></p>
<ul>
<li>发现错误的设备只向<mark>源主机</mark>报告差错，但<mark>不负责纠正错误</mark>，纠错留给高层协议；</li>
<li>差错报文作为一般数据传输，<mark>不享受特别的优先级和可靠性</mark>。</li>
<li>产生ICMP差错报文的同时会<mark>丢弃出错的IP数据报</mark>。</li>
</ul>
<p><strong>不应发送ICMP差错报告报文的几种情况</strong></p>
<ul>
<li>ICMP差错报文<mark>本身不会再产生ICMP差错报文</mark></li>
<li><mark>广播或组播地址的数据报</mark>不会产生ICMP差错报文</li>
<li><mark>分片的IP数据报的非第一个分片</mark>不会产生ICMP差错报文</li>
<li><mark>特殊地址0.0.0.0和127.0.0.1</mark>的报文不会产生ICMP差错报文</li>
</ul>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><strong>网络层已解决的问题</strong></p>
<ul>
<li>提供<strong>不可靠、无连接、尽力而为的数据报</strong>传送服务。</li>
<li>将数据报从一台主机经过网络送到另一台主机，实现<strong>主机之间的通信</strong>。</li>
</ul>
<p><strong>网络层未解决的问题</strong></p>
<ul>
<li>主机中<strong>谁发送的数据、谁接收数据</strong>？</li>
<li>IP数据报<strong>无序到达</strong>目的主机，接收进程如何处理？</li>
<li><strong>可靠传输问题</strong></li>
</ul>
<p><strong>运输层的作用</strong><br>对于高层用户而言，其主要起<strong>屏蔽作用</strong>：<br>屏蔽了下面网络核心的细节，使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。<br>对于低层用户而言，其主要起<strong>管控作用</strong>：<br>实现可靠传输、流量拥塞控制、运输连接管理</p>
<p><strong>运输层和网络层的区别</strong><br>运输层为应用进程之间提供端到端的逻辑通信，<strong>通信的真正端点是主机中的进程</strong>。<br>网络层为主机之间提供逻辑通信，<strong>通信的两端是两台主机</strong>。</p>
<p><strong>运输层的复用和分用</strong></p>
<ul>
<li>复用：应用进程都可以通过运输层再传送到网络层。</li>
<li>分用：运输层从网络层收到发送给应用进程的数据后，必须分别<br>交付给指明的各应用进程。</li>
</ul>
<blockquote>
<p><strong>复用过程（发送端）</strong><br>​</p>
<ul>
<li>多路合并：<br>主机A的不同应用进程（AP1/AP2/AP3）通过不同端口号（如80/443/21）发送数据,运输层为每个数据段添加首部（源端口+目的端口）</li>
<li>统一传输：<br>所有数据段通过同一运输层协议（如TCP/UDP）合并到IP数据报中进入网络层传输</li>
</ul>
<p><strong>分用过程（接收端）</strong></p>
<ul>
<li>端口识别：<br>运输层收到IP数据报后，通过首部中的目的端口号（如80对应Web服务）</li>
<li>精准分发：<br>根据端口号与进程绑定关系，将数据交付给主机B对应的应用进程</li>
</ul>
</blockquote>
<p><strong>端口</strong><br>端口是用来标识应用层的进程。</p>
<p><strong>两台计算机进程互相通信的前提</strong></p>
<ul>
<li>必须知道对方的<strong>IP地址</strong></li>
<li>必须知道对方的<strong>端口号</strong><br><img src="/2025/05/08/Network/122.png" alt="alt text"></li>
</ul>
<p><strong>三大端口号类型</strong></p>
<ul>
<li>服务器端口号：一般<strong>通过知名端口号来识别</strong>。</li>
<li>注册端口号：为没有知名端口号的应用程序所使用，<strong>主要用于一些不常用的服务，使用  前需注册</strong>。</li>
<li>客户端口号：<strong>只有在用户运行该客户进程时才存在，通信结束后被系统收回</strong></li>
</ul>
<p><img src="/2025/05/08/Network/123.png" alt="alt text"></p>
<h3 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h3><p><strong>*UDP和TCP的区别</strong></p>
<ol>
<li>收到报文后：UDP不需要给出确认，TCP需要确认</li>
<li>UDP支持单播、多播、广播；TCP仅支持点对点单播，不支持多播和广播</li>
<li>UDP 适用于对效率要求相对高、对准确性要求相对低的场景，TCP反之</li>
<li>UDP面向报文，TCP面向连接、面向字节流</li>
<li>TCP能够实现可靠传输、流量控制、超时重传、拥塞控制</li>
</ol>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p><strong>UDP 只在 IP 的数据报服务之上增加了少量功能：<mark>复用和分用、差错检测</mark></strong></p>
<p><strong>UDP数据报格式</strong><br>用户数据报 UDP 有两个字段：首部字段和数据字段。<strong>首部字段有8个字节</strong>，由4个字段组成，每个字段都是2个字节。</p>
<p><img src="/2025/05/08/Network/124.png" alt="alt text"></p>
<p><strong>伪首部</strong><br>伪首部不是UDP的真实首部，<strong>仅仅是为了<mark>计算校验和</mark>临时添加的</strong>。</p>
<p>UDP的校验和是把首部和数据部分一起检验：<br><img src="/2025/05/08/Network/125.png" alt="alt text"></p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP<strong>不保证</strong>接收端应用程序所收到的数据块和发送端应用程序所发出的<strong>数据块具有对应大小的关系</strong>，但接收端应用程序收到的字节流必须和发送端应用程序发出的<strong>字节流完全一样</strong>。</p>
<p><img src="/2025/05/08/Network/126.png" alt="alt text"></p>
<p><strong>TCP连接</strong><br><strong>TCP连接的端点叫做套接字(socket)或插口</strong><br><strong><mark>端口号拼接IP地址</mark>即构成了套接字</strong></p>
<p><img src="/2025/05/08/Network/127.png" alt="alt text"></p>
<p><strong>TCP报文段格式</strong><br><strong>TCP首部的最小长度是20字节。</strong><br><img src="/2025/05/08/Network/128.png" alt="alt text"></p>
<p>序号：<br>TCP 连接中传送的数据流中的<strong>每一个字节都有一个序号</strong>，序号字段的值则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>。<br><img src="/2025/05/08/Network/129.png" alt="alt text"></p>
<p>确认号：<br><strong>期望</strong>收到对方的下一个报文段的数据的<strong>第一个字节的序号</strong><br><img src="/2025/05/08/Network/130.png" alt="alt text"></p>
<p>SYN、FIN、ACK：<br><img src="/2025/05/08/Network/132.png" alt="alt text"></p>
<p>校验和：<br>字段检验的范围包括<strong>首部和数据</strong>两部分。在计算检验和时，要在TCP报文段的前面<strong>加上12字节的伪首部</strong>。</p>
<p><strong>最大报文段长度(MSS)</strong><br>最大报文段长度是每个<strong>TCP报文段中的数据字段的最大长度，<mark>与接收窗口值没有关系</mark>。</strong></p>
<p>MSS不能太小（网络利用率低）也不能太大（开销增大）</p>
<p><strong>TCP连接</strong><br>采用<strong>客户（主动发起）-服务器（被动等待）</strong>方式</p>
<p><mark><strong>TCP规定</strong></mark></p>
<ul>
<li>SYN 报文段（即 SYN = 1 的报文段）<strong>不能携带数据，但要分配一个序号</strong>。</li>
<li>ACK报文段可以携带数据，<strong>若不携带数据，则不分配序号</strong>。</li>
<li>FIN 报文段（即 FIN = 1 的报文段）<strong>即使不携带数据，也要分配一个序号</strong>。</li>
</ul>
<p>建立连接：三报文握手<br><img src="/2025/05/08/Network/133.png" alt="alt text"></p>
<p>连接释放：四报文握手<br><strong>必须等待 2 MSL（最长报文段寿命）</strong></p>
<p><strong>保活计时器</strong><br><strong>用来防止在TCP连接出现长时期的空闲。</strong></p>
<ul>
<li>保活计时器通常设置为<strong>2小时</strong>。</li>
<li>若服务器过了2小时还没有收到客户的数据，它就发送<strong>探测报文段</strong>。若发送了<strong>10个探测报文段（每一个相隔75秒）</strong>还没有响应，就认为客户的主机出了故障，终止连接。</li>
</ul>
<p><strong>TCP传输控制——可靠传输</strong></p>
<ol>
<li><p>停止等待协议<br><strong>要点：停止等待后再发送、暂存副本、编号、超时重传、信道利用率低</strong></p>
</li>
<li><p>连续ARQ协议<br><strong>要点：窗口，序号，确认，超时重传——实现可靠传输</strong></p>
</li>
</ol>
<p><strong>滑动窗口协议</strong><br><img src="/2025/05/08/Network/134.png" alt="alt text"></p>
<p><strong>累计确认</strong><br>接收方<strong>不必对收到的分组逐个发送确认</strong>，在收到<strong>几个分组</strong>后对按序到达的最后一个分组发送确认</p>
<p><strong>选择性确认（SACK）</strong><br><img src="/2025/05/08/Network/135.png" alt="alt text"></p>
<p><strong>连续ARQ协议和停止等待协议</strong><br><img src="/2025/05/08/Network/136.png" alt="alt text"></p>
<p><strong>TCP传输控制——流量控制</strong><br>流量控制：让发送方的发送速率不要太快，既要让接收方来得及接收，也不会使网络发生拥塞。<br>利用<strong>滑动窗口机制</strong>可以在TCP连接上实现对发送方的流量控制。</p>
<p><strong>TCP传输控制——超时重传</strong><br>超时重传时间（RTO）的设置<br><img src="/2025/05/08/Network/137.png" alt="alt text"><br><img src="/2025/05/08/Network/138.png" alt="alt text"></p>
<p><strong>$RTO$ 应略大于加权平均往返时间$RTT_S$</strong></p>
<p><strong>TCP传输控制——拥塞控制</strong></p>
<p><strong>拥塞控制与流量控制的区别</strong><br>拥塞控制是<strong>全局性问题</strong>，流量控制是<strong>端到端问题</strong>（抑制传输速率可以解决）</p>
<p>TCP 采用<strong>基于窗口</strong>的方法进行拥塞控制，该方法属于<strong>闭环控制</strong>方法。</p>
<ul>
<li>TCP 发送方维持一个拥塞窗口（cwnd）</li>
<li>cwnd的<mark><strong>大小取决于网络的拥塞程度</strong></mark>，并且是<strong>动态变化</strong>的。</li>
<li>只要网络<strong>没有出现拥塞，cwnd就可以再增大一些</strong>，以便把更多的分组发送出去，<strong>提高网络的利用率</strong>；只要网络出现拥塞或有可能出现拥塞，就必须把cwnd减小一些，以减少注入到网络中的分组数，缓解网络出现的拥塞。</li>
<li>发送方根据网络的拥塞情况，<strong>利用cwnd调整发送的数据量</strong>。<br><img src="/2025/05/08/Network/139.png" alt="alt text"></li>
</ul>
<blockquote>
<p><strong>开环控制和闭环控制的区别</strong><br><img src="/2025/05/08/Network/140.png" alt="alt text"></p>
</blockquote>
<p><strong>拥塞控制的两种方法：</strong></p>
<ol>
<li><p>慢启动<br><strong>每个RTT 内，每收到一个确认，cwnd + 1；</strong></p>
<blockquote>
<p><img src="/2025/05/08/Network/141.png" alt="alt text"></p>
</blockquote>
</li>
<li><p>拥塞避免<br><strong>每个 RTT 内，无论收到多少确认，cwnd + 1 (<mark>加法增大</mark>)；</strong><br><img src="/2025/05/08/Network/142.png" alt="alt text"></p>
</li>
<li><p>快速重传<br><strong>收到 3 个连续重复确认，立即重传丢失的报文段；</strong><br><img src="/2025/05/08/Network/143.png" alt="alt text"><br>接收方每次收到M4或M5时，会发送对最近缺失包（M3）​的重复确认</p>
</li>
<li><p>快速恢复<br><strong>收到 3 个连续重复确认，慢启动阈值= cwnd/2 ，执行拥塞避免算法</strong></p>
</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>运输层为应用进程提供了端到端的逻辑通信服务。<strong>应用层协议精确定义不同主机中的多个应用进程之间的通信规则。</strong><br><img src="/2025/05/08/Network/144.png" alt="alt text"></p>
<h3 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h3><p>用来把人们使用的<strong>机器名字（域名）转换为 IP 地址</strong></p>
<ul>
<li>采用<strong>层次树状结构</strong>的命名方法：www.ustb.edu.cn</li>
<li>DNS 是一个联机<strong>分布式数据库系统</strong>，采用<strong>客户/服务器</strong>工作方式。</li>
<li>域名到 IP 地址的解析是由<strong>若干个域名服务器程序</strong>共同完成。</li>
<li>域名服务器程序在专设的节点上运行，<strong>运行该程序的机器称为域名服务器</strong>。<br><img src="/2025/05/08/Network/145.png" alt="alt text"></li>
</ul>
<p>DNS 使用 <strong>UDP 通信</strong><br>域名解析方式包括<strong>递归解析和迭代解析</strong></p>
<ul>
<li>递归解析：<strong>主机向本地域名服务器</strong>发送域名解析请求时使用</li>
<li>迭代解析：<strong>本地域名服务器向根域名服务器</strong>发送域名解析请求时使用<br><img src="/2025/05/08/Network/146.png" alt="alt text"></li>
</ul>
<h3 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h3><p>DHCP 提供了<strong>即插即用连网</strong>的机制。<br><strong>DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。</strong></p>
<p>过程：<br>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送<strong>发现报文</strong>，这时该主机就成为DHCP 客户。</p>
<ul>
<li>本地网络上所有主机<strong>都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文</strong>。</li>
<li>DHCP服务器的回答报文叫做<br><strong>提供报文</strong>。</li>
<li>DHCP 使用<strong>客户-服务器</strong>方式，采用<strong>请求/应答方式</strong>工作。</li>
<li>DHCP 基于 <strong>UDP</strong> 工作，DHCP <strong>服务器运行在 67 号端口</strong>， DHCP <strong>客户运行在 68 号端口</strong>。</li>
</ul>
<p><img src="/2025/05/08/Network/147.png" alt="alt text"><br><img src="/2025/05/08/Network/148.png" alt="alt text"></p>
<p><strong>DHCP 中继代理</strong><br>并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络<strong>至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息</strong>。<br>当 DHCP 中继代理收到主机发送的发现报文后，就以<strong>单播方式向 DHCP 服务器</strong>转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p>
<p><strong>租用期</strong><br>DHCP 服务器<strong>分配给 DHCP 客户的 IP 地址的临时的</strong>，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2025/03/17/StackAndQueue/</url>
    <content><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><blockquote>
<p><strong>栈、队列、双端队列均是线性表的特殊情况（访问受限的线性表）</strong></p>
<p><img src="/2025/03/17/StackAndQueue/访问受限的线性表.png" alt="alt text"></p>
</blockquote>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>允许插入、删除的一端称为<mark>栈顶(top)</mark>，另一端称为<mark>栈底(bottom)</mark></li>
<li>在栈顶插入元素称为<mark>入栈(push)</mark>，删除元素称为<mark>出栈(pop)</mark></li>
</ul>
<h3 id="顺序栈——栈的顺序存储实现"><a href="#顺序栈——栈的顺序存储实现" class="headerlink" title="顺序栈——栈的顺序存储实现"></a>顺序栈——栈的顺序存储实现</h3><p><strong>顺序栈存储空间的处理</strong><br><img src="/2025/03/17/StackAndQueue/顺序栈存储空间的处理.png" alt="alt text"></p>
<p><strong>顺序栈的特点</strong>：</p>
<ol>
<li>顺序栈的入栈和出栈、构造和销毁的<mark>复杂度都是$O(1)$</mark></li>
<li>可以采用溢出时增容，或者<mark>共享栈</mark>的方式提高空间利用率</li>
</ol>
<h3 id="链式栈——栈的链式存储分配实现"><a href="#链式栈——栈的链式存储分配实现" class="headerlink" title="链式栈——栈的链式存储分配实现"></a>链式栈——栈的链式存储分配实现</h3><p><strong>链式栈的特点</strong>：</p>
<ol>
<li>链式栈的<mark>入栈和出栈复杂度为$O(1)$</mark>，<mark>构造和销毁的复杂度是$O(n)$<strong>(需要逐个释放/创建)</strong></mark></li>
<li>栈的长度动态变化，空间利用率高，一般<mark>无需判断溢出</mark></li>
</ol>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><ul>
<li><p><strong>十进制数到二进制数的转换</strong><br><img src="/2025/03/17/StackAndQueue/十进制转二进制.png" alt="alt text"><br><br></p>
</li>
<li><p><strong>算术表达式求值的栈实现</strong></p>
<p>  中缀表达式实现步骤：</p>
<ol>
<li>初始化:结束符‘#’入栈：<code>Sr.Push(‘#’)</code></li>
<li>如果W是操作数则入栈：<code>Sd.Push(W)</code></li>
<li>若W为运算符，则有以下几种情况:<ol>
<li>若W优先级高于Sr栈顶元素则入栈：<code>Sr.Push(W)</code></li>
<li>若W优先级低于Sr栈顶元素则执行运算操作:<br> <code>Sd.Pop(x1);</code><br> <code>Sd.Pop(x2);</code><br> <code>Sr.Pop(@);</code><br> <code>Sd.Push(x2@X1);</code></li>
<li>若W等于Sr栈顶元素则弹出Sr栈顶元素</li>
</ol>
</li>
<li><p>Sd即为运算结果<br><br></p>
<p>中缀转后缀表达式：<br>维护两个栈：运算符(OP)和结果栈(R)</p>
</li>
</ol>
<ul>
<li>扫描到操作数，R入栈;扫描到’(‘，OP入栈</li>
<li>扫描到运算符:<br>  当前运算符优先级高于OP栈顶元紊优先级，OP入栈<br>  否则，则OP栈出栈，R栈入栈</li>
<li>扫描到’)’，OP出栈，到pop出’)’为止。如果pop出的元素不是’(‘或’)’，则将元素压入R<br><img src="/2025/03/17/StackAndQueue/后缀表达式.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote>
<p><strong>适用情况：问题可以<mark>收敛</mark></strong></p>
</blockquote>
<ul>
<li><p><strong>阶乘求值</strong><br><img src="/2025/03/17/StackAndQueue/阶乘求值.png" alt="alt text"><br><br><br><br></p>
</li>
<li><p><strong>阿克曼函数</strong><br>特点：随着输入值的增加，函数的值<strong>增长得非常快</strong><br>定义如下：<br><img src="/2025/03/17/StackAndQueue/阿克曼函数定义.png" alt="alt text"><br>  递归实现：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">c</span>(m - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">c</span>(m - <span class="number">1</span>, <span class="built_in">c</span>(m, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">c</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
</li>
<li><p><strong>斐波那契数列</strong><br>递归定义：<br><img src="/2025/03/17/StackAndQueue/斐波那契定义.png" alt="alt text"><br><br></p>
<p>  递归实现：<br>  <img src="/2025/03/17/StackAndQueue/斐波那契实现.png" alt="alt text"><br>  F(5)的栈调用情况：<br>  <img src="/2025/03/17/StackAndQueue/斐波那契栈调用.png" alt="alt text"><br><br><br><br></p>
</li>
<li><p><strong>最大公约数</strong><br>定义：可以同时除尽两个正整数的最大的正整数<br><img src="/2025/03/17/StackAndQueue/最大公约数.png" alt="alt text"><br><br></p>
<p>  递归实现：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> a,<span class="type">unsigned</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = a % b;</span><br><span class="line">    <span class="keyword">if</span>(r != <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">gcd</span>(b，r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
</li>
<li><p><strong>互递归</strong><br>定义：一种非直接递归，两个函数互相借助对方定义<br>示例：<br><img src="/2025/03/17/StackAndQueue/互递归.png" alt="alt text"><br><br><br><br></p>
</li>
<li><p><strong>汉诺塔问题</strong><br>递归步骤：<br><img src="/2025/03/17/StackAndQueue/汉诺塔.png" alt="alt text"><br><br></p>
<p>  递归实现：<br>  <img src="/2025/03/17/StackAndQueue/汉诺塔实现.png" alt="alt text"><br>  <strong><em>先把 n - 1 个移动到y，然后移动最底下的到z，然后把 n - 1 个从y移动到z</em></strong><br><br></p>
<p>  复杂度分析：<br>  <img src="/2025/03/17/StackAndQueue/汉诺塔复杂度分析.png" alt="alt text"><br><br><br><br></p>
</li>
</ul>
<h3 id="递归的消去"><a href="#递归的消去" class="headerlink" title="递归的消去"></a>递归的消去</h3><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>定义：函数最后操作时<strong>递归调用或平凡返回</strong>（<mark>返回已经存在的值</mark>）</p>
<blockquote>
<p><strong>为什么需要尾递归？</strong><br>对于非尾递归来说，由于最后的返回值需要额外计算，因此<mark>经历了创建栈帧、销毁栈帧的过程，可能导致栈溢出</mark>。</p>
<p>以计算阶乘的普通递归实现为例:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当调用<code>factorial(3)</code>时，执行过程如下：</p>
<p>调用<code>factorial(3)</code>，<mark>创建栈帧A</mark>，保存参数n=3。<br>执行到<code>return n * factorial(n - 1)</code>时，需要先计算<code>factorial(2)</code>的值。</p>
<p>调用<code>factorial(2)</code>，<mark>创建新的栈帧B</mark>，保存参数n=2。<br>执行到<code>return n * factorial(n - 1)</code>时，需要先计算<code>factorial(1)</code>的值。</p>
<p>调用<code>factorial(1)</code>，<mark>创建新的栈帧C</mark>，保存参数n=1。<br>执行到<code>return n * factorial(n - 1)</code>时，需要先计算<code>factorial(0)</code>的值。</p>
<p>调用<code>factorial(0)</code>，<mark>创建新的栈帧D</mark>，保存参数n=0。<br>执行到return 1，返回值1，销毁栈帧D。</p>
<p>栈帧C继续执行，计算1 <em> 1=1，返回值1，<mark>销毁栈帧C</mark>。<br>栈帧B继续执行，计算2 </em> 1=2，返回值2，<mark>销毁栈帧B</mark>。<br>栈帧A继续执行，计算3 * 2=6，返回值6，<mark>销毁栈帧A</mark>。</p>
<p><strong><em>在这个过程中，每次递归调用都会创建新的栈帧，栈帧数量随着递归深度增加而增加，可能导致栈溢出，并且每次创建和销毁栈帧都会带来性能开销。</em></strong></p>
</blockquote>
<p><br></p>
<p><strong>尾递归优化的执行过程：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial_tail</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">factorial_tail</span>(n - <span class="number">1</span>, n * acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始调用时，acc的初始值为1。例如，计算<code>factorial_tail(3, 1)</code>的执行过程如下：<br>调用<code>factorial_tail(3, 1)</code>，<mark>创建栈帧A</mark>，保存参数n=3，acc=1。</p>
<p>执行到<code>return factorial_tail(n - 1, n * acc)</code>时，计算新的参数值n-1=2，n <em> acc=3</em>1=3。<br>调用<code>factorial_tail(2, 3)</code>，<mark>复用栈帧A</mark>，更新参数n=2，acc=3。</p>
<p>执行到<code>return factorial_tail(n - 1, n * acc)</code>时，计算新的参数值n-1=1，n <em> acc=2</em>3=6。<br>调用<code>factorial_tail(1, 6)</code>，<mark>复用栈帧A</mark>，更新参数n=1，acc=6。</p>
<p>执行到<code>return factorial_tail(n - 1, n * acc)</code>时，计算新的参数值n-1=0，n <em> acc=1</em>6=6。<br>调用<code>factorial_tail(0, 6)</code>，<mark>复用栈帧A</mark>，更新参数n=0，acc=6。</p>
<p>执行到<code>return acc</code>，返回值6，<mark>销毁栈帧A</mark>。</p>
<p><strong><em>在这个过程中，每次递归调用复用当前栈帧，不需要创建新的栈帧，因此栈帧数量始终保持为1，不会导致栈溢出，并且避免了创建和销毁栈帧的性能开销。</em></strong><br><br></p>
<p><strong>底层原理</strong><br><strong>尾递归优化的关键在于编译器能够识别出尾递归调用，并将其转换为循环操作</strong>。具体来说，当编译器检测到一个函数调用是尾递归时，它会生成代码来复用当前的栈帧，而不是创建新的栈帧。这通常是通过将递归调用的参数更新到当前栈帧的变量中，并跳转到函数的开头重新执行来实现的。<br><br></p>
<p><strong>常见简单问题的尾递归实现</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO...</span></span><br></pre></td></tr></table></figure><br><br><br><br></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p><strong>定义：限制数据一端插入，另一端删除的特殊线性表</strong></p>
<ul>
<li>允许插入的一端称为<mark>队尾(rear)</mark>，允许删除的一端称为<mark>队头(front)</mark></li>
<li>入队为<mark>Enqueue</mark>，出队为<mark>Dequeue</mark><br><br></li>
</ul>
</blockquote>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p><img src="/2025/03/17/StackAndQueue/顺序队列的存储.png" alt="alt text"><br><br></p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p><img src="/2025/03/17/StackAndQueue/顺序队列的操作.png" alt="alt text"><br><img src="/2025/03/17/StackAndQueue/顺序队列的操作2.png" alt="alt text"><br><strong>假溢出</strong>：rear已经到达数组末尾，尽管队列中仍有空闲空间（front之前的位置），但由于rear无法继续向后移动，导致假溢出。<br><br></p>
<h3 id="循环队列——解决假溢出问题"><a href="#循环队列——解决假溢出问题" class="headerlink" title="循环队列——解决假溢出问题"></a>循环队列——解决假溢出问题</h3><blockquote>
<p><strong><em>顺序数列无法利用队头指针之前的空间，因此假溢出的本质是没有完全利用数组空间。而循环数列通过连成环解决了这一问题。由于首尾相接，因此循环队列需要做的只是找到判空和判满的办法。</em></strong><br><br><br><img src="/2025/03/17/StackAndQueue/循环队列.png" alt="alt text"></p>
</blockquote>
<p><br></p>
<ul>
<li><p><strong>方法一：留出空位</strong><br><img src="/2025/03/17/StackAndQueue/留出空位.png" alt="alt text"><br>  判断条件：</p>
<ol>
<li>队列为空：<strong>front == rear</strong></li>
<li>队列为满：<strong>front == (rear + 1) % max</strong><br><br></li>
</ol>
</li>
<li><p><strong>其他方法易于理解</strong>：<br><img src="/2025/03/17/StackAndQueue/其他方法.png" alt="alt text"><br><br><br><br></p>
</li>
</ul>
<h3 id="链式队列——链式存储方式"><a href="#链式队列——链式存储方式" class="headerlink" title="链式队列——链式存储方式"></a>链式队列——链式存储方式</h3><p>和链表的逻辑一致，易于理解：<br><img src="/2025/03/17/StackAndQueue/链式队列.png" alt="alt text"></p>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>易于理解：<br><img src="/2025/03/17/StackAndQueue/优先队列.png" alt="alt text"></p>
<h3 id="队列的应用：杨辉三角"><a href="#队列的应用：杨辉三角" class="headerlink" title="队列的应用：杨辉三角"></a>队列的应用：杨辉三角</h3><p><img src="/2025/03/17/StackAndQueue/杨辉三角.png" alt="alt text"><br><br></p>
<h4 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h4><p>先进队一个1</p>
<blockquote>
<p>此时队列： 1      （这样我们就得到了杨辉三角的第一行）</p>
</blockquote>
<p><br><br><br></p>
<p>第一步：在队尾<mark>进队一个1</mark></p>
<blockquote>
<p>此时队列：1 1</p>
</blockquote>
<p><strong>循环0次</strong>（这里相当于没有进行操作）（看不懂就往下看）</p>
<blockquote>
<p>此时队列：1 1</p>
</blockquote>
<p>在队尾<mark>进队一个1</mark></p>
<blockquote>
<p>1 1 1</p>
</blockquote>
<p><mark>出队队头的一个1</mark></p>
<blockquote>
<p>1 1              （这样我们就得到了杨辉三角的第二行）</p>
</blockquote>
<p>（这里看不懂没关系，接着看就懂了）<br><br><br><br></p>
<p>第二步：在队尾<mark>进队一个1</mark>（与第一步中相同操作）</p>
<blockquote>
<p>1 1 1</p>
</blockquote>
<p><strong>循环一次：进队队头两个元素的和（1+1=2），即进队2</strong>；</p>
<blockquote>
<p>1 1 1 2</p>
</blockquote>
<p><strong>再出队队头的一个元素（1）。这两个操作为一次循环</strong>。</p>
<blockquote>
<p>1 1 2</p>
</blockquote>
<p>在队尾<mark>进队一个1</mark>（与第一步中相同操作）</p>
<blockquote>
<p>1 1 2 1</p>
</blockquote>
<p><mark>出队队头的一个1</mark></p>
<blockquote>
<p>1 2 1            （这样我们就得到了杨辉三角的第三行）</p>
</blockquote>
<p><br><br><br></p>
<p>第三步：</p>
<p>在队尾<mark>进队一个1</mark>（与第一步中相同操作）</p>
<blockquote>
<p>1 2 1 1</p>
</blockquote>
<p><strong>循环两次：第一次进队队头两个元素的和（1+2=3），即进队3</strong>；</p>
<blockquote>
<p>1 2 1 1 3</p>
</blockquote>
<p><strong>再出队队头的一个元素（1）。这两个操作为一次循环</strong>。</p>
<blockquote>
<p>2 1 1 3</p>
</blockquote>
<p><strong>第二次再进队队头两个元素的和（2+1=3），即进队3</strong>；</p>
<blockquote>
<p>2 1 1 3 3</p>
</blockquote>
<p><strong>再出队队头的一个元素（2）。这两个操作为第二次循环</strong>。</p>
<blockquote>
<p>1 1 3 3</p>
</blockquote>
<p>在队尾<mark>进队一个1</mark>（与第一步中相同操作）</p>
<blockquote>
<p>1 1 3 3 1</p>
</blockquote>
<p><mark>出队队头的一个1</mark></p>
<blockquote>
<p>1 3 3 1           （这样我们就得到了杨辉三角的第四行）</p>
</blockquote>
<p><br></p>
<blockquote>
<p>经过上面的三步操作，不难看出，每一步都分为<mark>三个部分</mark>。即：<strong><em>进1；循环；进1出1</em></strong>。所以我们可以控制重复上述步骤的次数，打印出想要的杨辉三角的层数。（并且可以看出，<strong>第一步循环0次；第二步循环1次；第三步循环2次。即循环次数为步数-1</strong>）</p>
</blockquote>
<p><br></p>
<h3 id="双栈实现队列"><a href="#双栈实现队列" class="headerlink" title="双栈实现队列"></a>双栈实现队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO...</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/2025/03/29/TreeAndBinaryTree/</url>
    <content><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p><strong><em>树（Tree）是n（n ≥ 0）个节点的有限集</em></strong></p>
</blockquote>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ul>
<li>节点的度：每个节点拥有子树的数目（后继的个数）</li>
<li>叶子节点：度为0的节点（没有后继的节点）</li>
<li>父节点：具有相同的父节点的节点</li>
<li>路径：任意两个节点是父子关系</li>
<li>树的度：树中<strong>节点度最大的值</strong></li>
<li>树的深度：树中<strong>节点的最大层次</strong></li>
<li>祖先节点：某节点到根节点的路径上所有的节点都是该节点的祖先节点</li>
<li>森林：m（m ≥ 0）课<strong>互不相交树</strong>的集合<br><img src="/2025/03/29/TreeAndBinaryTree/树的基本概念.jpg" alt="alt text"></li>
</ul>
<h3 id="树的基本性质"><a href="#树的基本性质" class="headerlink" title="树的基本性质"></a>树的基本性质</h3><ul>
<li><p>性质一：节点数等于节点的度的总和加一<br><br></p>
</li>
<li><p>性质二：度为 k 的树，第 i 层至多有 $k^i - 1$ 个节点<br><br></p>
</li>
<li><p>性质三：度为 k 且深度为 h 的树至多有 $(k^h - 1)/(k - 1)$ 个节点<br><br></p>
</li>
<li><p>性质四：具有 n 个节点的度为 k 的树的最小深度为 $[log_k(n(k -1) + 1)]$ (向上取整)</p>
</li>
</ul>
<p><strong>其他性质：</strong></p>
<ul>
<li>边数等于度数之和</li>
<li>边数等于节点数减一</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p><strong><em>二叉树（Binary Tree）是n（n ≥ 0）个节点的有限集</em></strong></p>
<p>有且只有一个根节点，L称为左子树，R称为右子树，两者不能互换位置。<br>二叉树每个节点最多有两个孩子<br>二叉树仅有五种基本形态：<br><img src="/2025/03/29/TreeAndBinaryTree/二叉树的五种基本形态.png" alt="alt text"></p>
</blockquote>
<p><font size="4"><strong><em>注意</em></strong>：</font></p>
<ul>
<li><strong><em>二叉树并不是树的特殊情况，两者是并列的</em></strong>&lt;/font&gt;</li>
<li><strong><em>二叉树不是度为2的树，因为二叉树可以是空树，而度为2的树不可以</em></strong></li>
</ul>
<h3 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h3><ul>
<li>性质一：第 i 层至多有 $2^{i-1}$ 个节点<br><br></li>
<li><p>性质二：深度为 <em>h</em> 的二叉树至多有 $2^h - 1$ 个节点(跟<strong>树的性质三</strong>类似)</p>
<blockquote>
<p><strong><em>满二叉树和完全二叉树</em></strong></p>
<p><img src="/2025/03/29/TreeAndBinaryTree/满二叉树和完全二叉树.png" alt="alt text"><br>完全二叉树不能只有右孩子</p>
</blockquote>
</li>
<li><p>性质三：任何非空二叉树，叶子节点数为 $n_0$ ,度为 2 的节点数为 $n_2$ ，则一定有：$n_0 = n_2 + 1$<br><br></p>
</li>
<li>性质四：具有 <em>n</em> 个节点的完全二叉树的深度为 $[ log_2(n + 1) ]$ (向上取整)(跟<strong>树的性质四</strong>类似)<br><strong><em>节点数相同的二叉树中，完全二叉树具有最小深度</em></strong><br><br></li>
<li>性质五：对具有 n 个节点的完全二叉树的节点进行自上而下，每层自左向右的编号0,1,2,…,n-1,则有：<br><img src="/2025/03/29/TreeAndBinaryTree/完全二叉树的性质.png" alt="alt text"></li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><ul>
<li>对二叉树节点从上到下，每层从左到右顺序编号</li>
<li>按照编号顺序将节点数据元素放入数组<br><img src="/2025/03/29/TreeAndBinaryTree/二叉树的顺序存储.png" alt="alt text"></li>
</ul>
<p>特点：</p>
<ul>
<li>节点间关系蕴含在其存储位置中</li>
<li>浪费空间，更用于满二叉树和完全二叉树。仅有 h 个节点的深度为 h 的二叉树空间利用率最低：$h/(2^h - 1)$</li>
</ul>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><ul>
<li><p>二叉链表：每个节点包含数据域，左孩子指针域和右孩子指针域<br><img src="/2025/03/29/TreeAndBinaryTree/二叉链表表示.png" alt="alt text"></p>
</li>
<li><p>三叉链表：节点增加一个存放指向父节点的指针<br><img src="/2025/03/29/TreeAndBinaryTree/三叉链表表示.png" alt="alt text"></p>
</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2025/03/29/TreeAndBinaryTree/二叉树的遍历.png" alt="alt text"><br><br></p>
<p>遍历规则：</p>
<ul>
<li>前序遍历:D-&gt;L-&gt;R —&gt; <strong>根 左 右</strong></li>
<li>中序遍历:L-&gt;D-&gt;R —&gt; <strong>左 根 右</strong></li>
<li>后序遍历:L-&gt;R-&gt;D —&gt; <strong>左 右 根</strong></li>
<li>层序遍历:从低到高逐层遍历</li>
</ul>
<p>技巧：</p>
<ul>
<li>对于前序，在左上方做标记</li>
<li>对于中序，在正下方做标记</li>
<li>对于后序，在右上方做标记</li>
</ul>
<p><strong><em>所有序列都逆时针遍历，根据标记可以得到遍历结果</em></strong><br><br></p>
<p><img src="/2025/03/29/TreeAndBinaryTree/二叉树的遍历技巧.png" alt="alt text"></p>
<h2 id="二叉树遍历的递归实现"><a href="#二叉树遍历的递归实现" class="headerlink" title="二叉树遍历的递归实现"></a>二叉树遍历的递归实现</h2><p>递归工作栈<strong>最大深度和树的深度一致</strong></p>
<ul>
<li>最好情况，空间复杂度为$O(log_2n)$</li>
<li>最坏情况，空间复杂度为$O(n)$</li>
</ul>
<p>前序遍历的代码实现：</p>
<ul>
<li><mark>入栈前访问</mark></li>
<li>如果右孩子为空，则弹出栈顶元素（相当于回溯到父节点）<mark>Pop函数是弹出栈顶元素并赋值</mark><br><br></li>
</ul>
<p><img src="/2025/03/29/TreeAndBinaryTree/前序遍历实现.png" alt="alt text"><br><br></p>
<p>中序遍历的代码实现：</p>
<ul>
<li><mark>出栈后访问</mark><br><br></li>
</ul>
<p><img src="/2025/03/29/TreeAndBinaryTree/中序遍历实现.png" alt="alt text"><br><br></p>
<p>后序遍历的代码实现：<br>节点没有右孩子，或者右孩子刚被访问，则访问父节点<br><br></p>
<p><img src="/2025/03/29/TreeAndBinaryTree/后序遍历实现1.png" alt="alt text"><br><img src="/2025/03/29/TreeAndBinaryTree/后序遍历实现2.png" alt="alt text"><br><br></p>
<p>层序遍历的代码实现：</p>
<ul>
<li>使用了队列去实现<br><br></li>
</ul>
<p><img src="/2025/03/29/TreeAndBinaryTree/后序遍历实现1.png" alt="alt text"><br><br></p>
<blockquote>
<p><strong>重要结论：</strong><br>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二又树。<br>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。<br>但是已知前序遍历序列和后序遍历序列，是不能确定一棵二又树的。<br><br><br><strong>why?</strong><br>前序遍历：第一个是根节点；后序遍历：最后一个是根节点<br>中序遍历：根节点在中间，左边是左子树右边是右子树<br><br><br><img src="/2025/03/29/TreeAndBinaryTree/二叉树构造规律.png" alt="alt text"></p>
</blockquote>
<h2 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h2><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p><strong>伟大始于渺小</strong></p>
<p><img src="/2025/03/29/TreeAndBinaryTree/最优二叉树.png" alt="alt text"><br><br></p>
</blockquote>
<p>路径和路径长度<br><img src="/2025/03/29/TreeAndBinaryTree/路径和路径长度.png" alt="alt text"></p>
<p>树的路径长度：从根到叶子节点的所有路径长度之和<br><strong><em><mark>节点数目相同</mark>的二叉树中，<mark>完全二叉树</mark>是路径长度最短的二叉树</em></strong><br><img src="/2025/03/29/TreeAndBinaryTree/树的路径长度.png" alt="alt text"><br><br></p>
<p>树的带权路径长度：所有根到叶子节点带权路径长度之和<br><img src="/2025/03/29/TreeAndBinaryTree/树的带权路径长度.png" alt="alt text"></p>
<h4 id="最优二叉树的构造"><a href="#最优二叉树的构造" class="headerlink" title="最优二叉树的构造"></a>最优二叉树的构造</h4><p>较为简单<br><img src="/2025/03/29/TreeAndBinaryTree/最优二叉树的构造.png" alt="alt text"></p>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>优点：</p>
<ul>
<li>概率大的路径短，概率小的路径长，使得树的带权路径长度短</li>
<li>任何字符编码都不是其他编码前缀，不会出现歧义<br><img src="/2025/03/29/TreeAndBinaryTree/哈夫曼编码.png" alt="alt text"></li>
</ul>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>左子树小于根节点，右子树大于根节点</li>
<li><strong>中序遍历二叉搜索树可以得到递增数列</strong></li>
<li>查找的复杂度可能会从$O(log_2n)$<strong>退化为</strong>$O(n)$（不平衡的情况）<br><br></li>
</ul>
</blockquote>
<p><strong><em><mark>中序遍历结果相同的二叉搜索树不唯一</mark></em></strong><br><img src="/2025/03/29/TreeAndBinaryTree/中序遍历结果.png" alt="alt text"></p>
<h4 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h4><p>用节点的<mark>中序遍历</mark>的前驱/后继代替<br>e.g.<br><img src="/2025/03/29/TreeAndBinaryTree/二叉搜索树的删除.png" alt="alt text"></p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>真正的“平衡树”</li>
<li>树的深度为 log~2~n</li>
<li>节点需要额外存储平衡因子</li>
<li>插入/删除会导致旋转操作以维持平衡<h4 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h4>节点的平衡因子是其左子树深度减去右子树深度，平衡因子绝对值越小，树越对称<br><strong><em>AVL树所有节点的平衡因子取值只能是-1,0,1</em></strong><br><img src="/2025/03/29/TreeAndBinaryTree/平衡因子.png" alt="alt text"></li>
</ul>
</blockquote>
<h4 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h4><p>右旋转<br>代码实现：<br><img src="/2025/03/29/TreeAndBinaryTree/右旋转代码.png" alt="alt text"><br>步骤：</p>
<ul>
<li>根节点的父亲指向子节点</li>
<li>子节点的右孩子成为根节点的左孩子</li>
<li>“交换父子关系”：根节点成为子节点的右孩子<br><img src="/2025/03/29/TreeAndBinaryTree/右旋转图解.png" alt="alt text"><br><br></li>
</ul>
<p>左旋转<br>代码实现：<br><img src="/2025/03/29/TreeAndBinaryTree/左旋转代码.png" alt="alt text"><br>步骤：</p>
<ul>
<li>根节点的父亲指向子节点</li>
<li>子节点的左孩子成为根节点的右孩子</li>
<li>“交换父子关系”：根节点成为子节点的左孩子<br><img src="/2025/03/29/TreeAndBinaryTree/左旋转图解.png" alt="alt text"></li>
</ul>
<h4 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h4><p>节点插入会破坏树的平衡性，需要进行旋转达到平衡</p>
<p>插入“18”，根节点的<strong>平衡因子变为2</strong>，因此需要进行旋转<br><img src="/2025/03/29/TreeAndBinaryTree/节点插入.png" alt="alt text"></p>
<p>不能随意旋转，最终还是要看是否所有平衡因子达到要求<br><img src="/2025/03/29/TreeAndBinaryTree/节点插入2.png" alt="alt text"><br>可进行多次旋转<br><img src="/2025/03/29/TreeAndBinaryTree/节点插入3.png" alt="alt text"><br><img src="/2025/03/29/TreeAndBinaryTree/节点插入4.png" alt="alt text"></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>一种“自平衡”的二叉查找树，可以应对极端情况O(N)</li>
<li>复杂度介于 O(log~2~N)和O(N)</li>
<li>是一种接近平衡的二叉树</li>
</ul>
</blockquote>
<p>红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（<mark>最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍</mark>）。它同时满足以下特性：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点</li>
<li>红色节点的子节点都是黑色;红色节点的父节点都是黑色;从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点</li>
<li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>e.g.<br><img src="/2025/03/29/TreeAndBinaryTree/红黑树判断.png" alt="alt text"><br>上面这棵树首先很容易就能知道是满足性质1-4条的，关键在于第5条性质，可能乍一看好像也是符合第5条的，但实际就会陷入一个误区，直接将图上的最后一层的节点看作叶子节点，这样看的话每一条从根节点到叶子结点的路径确实都经过了3个黑节点。</p>
<p>但实际上，<strong><em>在红黑树中真正被定义为叶子结点的，是那些空节点</em></strong>，如下图。<br><img src="/2025/03/29/TreeAndBinaryTree/红黑树判断2.png" alt="alt text"><br>这样一来，路径1有4个黑色节点（算上空节点），路径2只有3个黑色节点，这样性质5就不满足了，<strong>所以这棵树并不是一个红黑树节点</strong>。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p><mark>红黑树的查找，插入和删除操作，时间复杂度都是$O(logN)$</mark>。</p>
<p><strong>查找</strong>操作时，它和普通的相对平衡的二叉搜索树的效率相同，<strong>都是通过相同的方式来查找的，没有用到红黑树特有的特性</strong>。</p>
<p>但如果<strong>插入</strong>的时候是<strong>有序数据</strong>，那么红黑树的查询效率就比二叉搜索树要高了，因为<strong>此时二叉搜索树不是平衡树，它的时间复杂度$O(N)$</strong>。</p>
<p>插入和删除操作时，由于红黑树的每次操作平均要旋转一次和变换颜色，所以它比普通的二叉搜索树效率要低一点，不过时间复杂度仍然是$O(logN)$。<strong><em><mark>总之，红黑树的优点就是对有序数据的查询操作不会慢到$O(logN)$的时间复杂度</mark></em></strong>。</p>
<h4 id="与AVL树的比较"><a href="#与AVL树的比较" class="headerlink" title="与AVL树的比较"></a>与AVL树的比较</h4><ol>
<li>AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异</li>
<li>红黑树的<strong>插入和删除操作</strong>比AVL树更便于控制操作</li>
<li>红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）<ol>
<li>对于AVL树来说，搜索、添加、删除都是 $O(logn)$ 复杂度，其中<strong>添加仅需 $O(1)$ 次旋转调整、删除最多需要 $O(logn)$ 次旋转调整</strong></li>
<li>对于红黑树来说，搜索、添加、删除都是 $O(logn)$ 复杂度，其中<strong>添加、删除都仅需 $O(1)$ 次旋转调整</strong></li>
<li>AVL树通过严格的平衡条件确保树的高度始终接近理论下限。这使得<mark>搜索操作更快，因为路径更短</mark>。</li>
<li>红黑树通过颜色标记和宽松的平衡规则（如根到叶子的最长路径不超过最短路径的两倍）。虽然<mark>搜索效率略低于AVL树，但插入和删除操作更高效</mark></li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>搜索的次数远远大于插入和删除</strong>，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树</li>
<li>相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树</li>
<li>红黑树的<strong>平均统计性能优于AVL树</strong>，实际应用中更多选择使用红黑树</li>
</ul>
</blockquote>
]]></content>
  </entry>
</search>
